{"version":3,"file":"lib_index_js.9edcdbe5c5a75e025f3b.js","mappings":";;;;;;;;;;;;;;;AAAA;AACqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,+DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://jupyterlab_prolog_codemirror_extension/./lib/index.js"],"sourcesContent":["/// <reference path=\"../node_modules/@jupyterlab/codemirror/typings/codemirror/codemirror.d.ts\" />\nimport { ICodeMirror } from '@jupyterlab/codemirror';\nfunction prologMode() {\n    return {\n        startState: function () {\n            return {\n                state: \"initial\",\n            };\n        },\n        token: function (stream, state) {\n            switch (state.state) {\n                case \"initial\":\n                    if (stream.match(/^\\%/)) {\n                        // Line comment -> consume the rest of the line\n                        stream.match(/^.+/);\n                        return \"comment\";\n                    }\n                    else if (stream.match(/^\\/\\*/)) {\n                        // Block comment start -> switch to comment state\n                        state.state = \"comment\";\n                        return \"comment\";\n                    }\n                    else if (stream.match(/^\"(?:[^\"])*\"/)) {\n                        return \"string\";\n                    }\n                    else if (stream.match(/^'(?:[^'])*'/)) {\n                        return \"atom\";\n                    }\n                    else if (stream.match(/^(?:[0-9]+)/)) {\n                        return \"number\";\n                    }\n                    else if (stream.match(/^(?:!)/)) {\n                        return \"builtin\";\n                    }\n                    else if (stream.match(/^(?:=:=|:-|@<|@>|@=<|@>=|[-+\\\\/><=*#$?^])/)) {\n                        return \"operator\";\n                    }\n                    else if (stream.match(/^[\\s()\\[\\]{},\\.|;@]+/)) {\n                        return null;\n                    }\n                    else if (stream.match(/^:+/)) {\n                        // \":\" needs to be checked on its own\n                        // Otherwise, if \":-\" occurs after one of the characters above (e.g. \")\"), \":\" would not be highlighted correctly\n                        return null;\n                    }\n                    else {\n                        const atom_or_variable = stream.match(/^[A-Za-z_]+[A-Za-z_0-9]*/);\n                        if (atom_or_variable && atom_or_variable.toString() !== \"\") {\n                            var firstCharacter = atom_or_variable.toString().charAt(0);\n                            if (firstCharacter !== \"_\" && firstCharacter === firstCharacter.toLowerCase()) {\n                                // If the token starts with a lower case letter, it is an atom\n                                if (stream.peek() === \"(\") {\n                                    // Atoms which are preceded by \"(\" are highlighted differently\n                                    return \"builtin\";\n                                }\n                                else {\n                                    return \"atom\";\n                                }\n                            }\n                            else {\n                                return \"variable-2\";\n                            }\n                        }\n                        else {\n                            // Consume the rest of the line and mark it as an error\n                            stream.match(/^.+/);\n                            return \"error\";\n                        }\n                    }\n                case \"comment\":\n                    while (!stream.eol()) {\n                        // Consume everything except for \"*\"\n                        stream.match(/^[^\\*]+/);\n                        if (stream.match(/^\\*\\//)) {\n                            // \"*/\" -> switch back to initial state\n                            state.state = \"initial\";\n                            return \"comment\";\n                        }\n                        else {\n                            // \"*\" without \"/\" -> consume and stay in comment state\n                            stream.match(/^\\*/);\n                        }\n                    }\n                    return \"comment\";\n                default:\n                    throw new Error(\"Unhandled state: \" + state.state);\n            }\n        }\n    };\n}\n;\nfunction definePrologMode(code_mirror) {\n    code_mirror.defineMode(\"prolog\", prologMode, \"Prolog\");\n    code_mirror.defineMIME('text/x-prolog', 'prolog');\n    code_mirror.modeInfo.push({\n        ext: ['pl'],\n        mime: 'text/x-prolog',\n        mode: 'prolog',\n        name: 'Prolog'\n    });\n}\nconst plugin = {\n    id: 'jupyterlab_prolog_codemirror_extension:plugin',\n    autoStart: true,\n    requires: [ICodeMirror],\n    activate: (app, codeMirror) => {\n        definePrologMode(codeMirror.CodeMirror);\n        console.log('JupyterLab extension jupyterlab_prolog_codemirror_extension is activated!');\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}