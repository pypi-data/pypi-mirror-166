"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Contains the definitions for Microgrid gRPC API.

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""
import builtins
import collections.abc
import frequenz.api.microgrid.battery_pb2
import frequenz.api.microgrid.common_pb2
import frequenz.api.microgrid.ev_charger_pb2
import frequenz.api.microgrid.inverter_pb2
import frequenz.api.microgrid.meter_pb2
import frequenz.api.microgrid.sensor_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ComponentCategory:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ComponentCategoryEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ComponentCategory.ValueType], builtins.type):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    COMPONENT_CATEGORY_UNSPECIFIED: _ComponentCategory.ValueType  # 0
    """An unknown component categories, useful for error handling, and marking
    unknown components in a list of components with otherwise known categories.
    """
    COMPONENT_CATEGORY_GRID: _ComponentCategory.ValueType  # 1
    """The point where the local microgrid is connected to the grid."""
    COMPONENT_CATEGORY_METER: _ComponentCategory.ValueType  # 2
    """A meter, for measuring electrical metrics, e.g., current, voltage, etc."""
    COMPONENT_CATEGORY_INVERTER: _ComponentCategory.ValueType  # 3
    """An electricity generator, with batteries or solar energy."""
    COMPONENT_CATEGORY_CONVERTER: _ComponentCategory.ValueType  # 4
    """A DC-DC converter."""
    COMPONENT_CATEGORY_BATTERY: _ComponentCategory.ValueType  # 5
    """A storage system for electrical energy, used by inverters."""
    COMPONENT_CATEGORY_EV_CHARGER: _ComponentCategory.ValueType  # 6
    """A station for charging electrical vehicles."""
    COMPONENT_CATEGORY_SENSOR: _ComponentCategory.ValueType  # 7
    """A sensor for measuring ambient metrics, e.g., temperature, humidity, etc."""
    COMPONENT_CATEGORY_CRYPTO_MINER: _ComponentCategory.ValueType  # 8
    """A crypto miner."""
    COMPONENT_CATEGORY_ELECTROLYZER: _ComponentCategory.ValueType  # 9
    """An electrolyzer for converting water into hydrogen and oxygen."""
    COMPONENT_CATEGORY_CHP: _ComponentCategory.ValueType  # 10
    """A heat and power combustion plant (CHP stands for combined heat and power)."""
    COMPONENT_CATEGORY_LOAD: _ComponentCategory.ValueType  # 14
    """An electrical load in the microgrid, consuming AC electricity.
    Note that this will be removed in the next release.
    """
    COMPONENT_CATEGORY_JUNCTION: _ComponentCategory.ValueType  # 15
    """A node in the circuit, where all connections meet.
    Note that this will be removed in the next release.
    """

class ComponentCategory(_ComponentCategory, metaclass=_ComponentCategoryEnumTypeWrapper):
    """Enumrated component categories."""

COMPONENT_CATEGORY_UNSPECIFIED: ComponentCategory.ValueType  # 0
"""An unknown component categories, useful for error handling, and marking
unknown components in a list of components with otherwise known categories.
"""
COMPONENT_CATEGORY_GRID: ComponentCategory.ValueType  # 1
"""The point where the local microgrid is connected to the grid."""
COMPONENT_CATEGORY_METER: ComponentCategory.ValueType  # 2
"""A meter, for measuring electrical metrics, e.g., current, voltage, etc."""
COMPONENT_CATEGORY_INVERTER: ComponentCategory.ValueType  # 3
"""An electricity generator, with batteries or solar energy."""
COMPONENT_CATEGORY_CONVERTER: ComponentCategory.ValueType  # 4
"""A DC-DC converter."""
COMPONENT_CATEGORY_BATTERY: ComponentCategory.ValueType  # 5
"""A storage system for electrical energy, used by inverters."""
COMPONENT_CATEGORY_EV_CHARGER: ComponentCategory.ValueType  # 6
"""A station for charging electrical vehicles."""
COMPONENT_CATEGORY_SENSOR: ComponentCategory.ValueType  # 7
"""A sensor for measuring ambient metrics, e.g., temperature, humidity, etc."""
COMPONENT_CATEGORY_CRYPTO_MINER: ComponentCategory.ValueType  # 8
"""A crypto miner."""
COMPONENT_CATEGORY_ELECTROLYZER: ComponentCategory.ValueType  # 9
"""An electrolyzer for converting water into hydrogen and oxygen."""
COMPONENT_CATEGORY_CHP: ComponentCategory.ValueType  # 10
"""A heat and power combustion plant (CHP stands for combined heat and power)."""
COMPONENT_CATEGORY_LOAD: ComponentCategory.ValueType  # 14
"""An electrical load in the microgrid, consuming AC electricity.
Note that this will be removed in the next release.
"""
COMPONENT_CATEGORY_JUNCTION: ComponentCategory.ValueType  # 15
"""A node in the circuit, where all connections meet.
Note that this will be removed in the next release.
"""
global___ComponentCategory = ComponentCategory

class ComponentFilter(google.protobuf.message.Message):
    """Parameters for filtering the components."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IDS_FIELD_NUMBER: builtins.int
    CATEGORIES_FIELD_NUMBER: builtins.int
    @property
    def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Return components that have the specified IDs only."""
    @property
    def categories(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___ComponentCategory.ValueType]:
        """Return components that have the specified categories only."""
    def __init__(
        self,
        *,
        ids: collections.abc.Iterable[builtins.int] | None = ...,
        categories: collections.abc.Iterable[global___ComponentCategory.ValueType] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["categories", b"categories", "ids", b"ids"]) -> None: ...

global___ComponentFilter = ComponentFilter

class ComponentIdParam(google.protobuf.message.Message):
    """Encapsulation of a component ID, intended to be used as a parameter for rpc
    methods.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.int
    def __init__(
        self,
        *,
        id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id"]) -> None: ...

global___ComponentIdParam = ComponentIdParam

class ConnectionFilter(google.protobuf.message.Message):
    """Parameters for filtering the component connections"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STARTS_FIELD_NUMBER: builtins.int
    ENDS_FIELD_NUMBER: builtins.int
    @property
    def starts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Only return connections that start from the specified component ID(s):
        if empty, connections with any `start` will be returned
        """
    @property
    def ends(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Only return connections that end at the specified component ID(s):
        if empty, connections with any `end` will be returned
        """
    def __init__(
        self,
        *,
        starts: collections.abc.Iterable[builtins.int] | None = ...,
        ends: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ends", b"ends", "starts", b"starts"]) -> None: ...

global___ConnectionFilter = ConnectionFilter

class PowerLevelParam(google.protobuf.message.Message):
    """Parameters for setting the charge/discharge power of an appropriate
    component.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPONENT_ID_FIELD_NUMBER: builtins.int
    POWER_W_FIELD_NUMBER: builtins.int
    component_id: builtins.int
    """The ID of the component to set the output power of."""
    power_w: builtins.int
    """The output power level, in watts. This is always a +ve integer. The sign
    of the power level is controlled by the implementations of the `Charge`
    and `Discharge` RPC methods.
    """
    def __init__(
        self,
        *,
        component_id: builtins.int = ...,
        power_w: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["component_id", b"component_id", "power_w", b"power_w"]) -> None: ...

global___PowerLevelParam = PowerLevelParam

class SetBoundsParam(google.protobuf.message.Message):
    """Parameters for setting bounds of a given metric of a given component."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _TargetMetric:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TargetMetricEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[SetBoundsParam._TargetMetric.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TARGET_METRIC_UNSPECIFIED: SetBoundsParam._TargetMetric.ValueType  # 0
        TARGET_METRIC_POWER_ACTIVE: SetBoundsParam._TargetMetric.ValueType  # 1

    class TargetMetric(_TargetMetric, metaclass=_TargetMetricEnumTypeWrapper):
        """An enumerated list of metrics whose bounds can be set."""

    TARGET_METRIC_UNSPECIFIED: SetBoundsParam.TargetMetric.ValueType  # 0
    TARGET_METRIC_POWER_ACTIVE: SetBoundsParam.TargetMetric.ValueType  # 1

    COMPONENT_ID_FIELD_NUMBER: builtins.int
    TARGET_METRIC_FIELD_NUMBER: builtins.int
    BOUNDS_FIELD_NUMBER: builtins.int
    component_id: builtins.int
    """The ID of the target component."""
    target_metric: global___SetBoundsParam.TargetMetric.ValueType
    """The target metric whose bounds have to be set."""
    @property
    def bounds(self) -> frequenz.api.microgrid.common_pb2.Bounds:
        """The bounds for the target metric."""
    def __init__(
        self,
        *,
        component_id: builtins.int = ...,
        target_metric: global___SetBoundsParam.TargetMetric.ValueType = ...,
        bounds: frequenz.api.microgrid.common_pb2.Bounds | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bounds", b"bounds"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bounds", b"bounds", "component_id", b"component_id", "target_metric", b"target_metric"]) -> None: ...

global___SetBoundsParam = SetBoundsParam

class Component(google.protobuf.message.Message):
    """A generic message for components. It is used to represent any category of
    component, with its static parameters.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    CATEGORY_FIELD_NUMBER: builtins.int
    MANUFACTURER_FIELD_NUMBER: builtins.int
    MODEL_NAME_FIELD_NUMBER: builtins.int
    BATTERY_FIELD_NUMBER: builtins.int
    INVERTER_FIELD_NUMBER: builtins.int
    METER_FIELD_NUMBER: builtins.int
    EV_CHARGER_FIELD_NUMBER: builtins.int
    SENSOR_FIELD_NUMBER: builtins.int
    id: builtins.int
    """A unique identifier for the component."""
    name: builtins.str
    """An optional name for the component."""
    category: global___ComponentCategory.ValueType
    """The category of the component."""
    manufacturer: builtins.str
    """The component manufacturer."""
    model_name: builtins.str
    """The model name of the component."""
    battery: frequenz.api.microgrid.battery_pb2.Type.ValueType
    inverter: frequenz.api.microgrid.inverter_pb2.Type.ValueType
    meter: frequenz.api.microgrid.meter_pb2.Type.ValueType
    ev_charger: frequenz.api.microgrid.ev_charger_pb2.Type.ValueType
    sensor: frequenz.api.microgrid.sensor_pb2.Type.ValueType
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        name: builtins.str = ...,
        category: global___ComponentCategory.ValueType = ...,
        manufacturer: builtins.str = ...,
        model_name: builtins.str = ...,
        battery: frequenz.api.microgrid.battery_pb2.Type.ValueType = ...,
        inverter: frequenz.api.microgrid.inverter_pb2.Type.ValueType = ...,
        meter: frequenz.api.microgrid.meter_pb2.Type.ValueType = ...,
        ev_charger: frequenz.api.microgrid.ev_charger_pb2.Type.ValueType = ...,
        sensor: frequenz.api.microgrid.sensor_pb2.Type.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["battery", b"battery", "ev_charger", b"ev_charger", "inverter", b"inverter", "meter", b"meter", "sensor", b"sensor", "type", b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["battery", b"battery", "category", b"category", "ev_charger", b"ev_charger", "id", b"id", "inverter", b"inverter", "manufacturer", b"manufacturer", "meter", b"meter", "model_name", b"model_name", "name", b"name", "sensor", b"sensor", "type", b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type", b"type"]) -> typing_extensions.Literal["battery", "inverter", "meter", "ev_charger", "sensor"] | None: ...

global___Component = Component

class ComponentList(google.protobuf.message.Message):
    """A message containing a list of components, used as a return typ in certain
    RPC methods.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPONENTS_FIELD_NUMBER: builtins.int
    @property
    def components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Component]: ...
    def __init__(
        self,
        *,
        components: collections.abc.Iterable[global___Component] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["components", b"components"]) -> None: ...

global___ComponentList = ComponentList

class ComponentData(google.protobuf.message.Message):
    """A generic container for data that can originate from any component type."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TS_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    METER_FIELD_NUMBER: builtins.int
    INVERTER_FIELD_NUMBER: builtins.int
    BATTERY_FIELD_NUMBER: builtins.int
    EV_CHARGER_FIELD_NUMBER: builtins.int
    SENSOR_FIELD_NUMBER: builtins.int
    @property
    def ts(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The timestamp of when the data was measured."""
    id: builtins.int
    """The component ID."""
    @property
    def meter(self) -> frequenz.api.microgrid.meter_pb2.Meter: ...
    @property
    def inverter(self) -> frequenz.api.microgrid.inverter_pb2.Inverter: ...
    @property
    def battery(self) -> frequenz.api.microgrid.battery_pb2.Battery: ...
    @property
    def ev_charger(self) -> frequenz.api.microgrid.ev_charger_pb2.EVCharger: ...
    @property
    def sensor(self) -> frequenz.api.microgrid.sensor_pb2.Sensor: ...
    def __init__(
        self,
        *,
        ts: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        id: builtins.int = ...,
        meter: frequenz.api.microgrid.meter_pb2.Meter | None = ...,
        inverter: frequenz.api.microgrid.inverter_pb2.Inverter | None = ...,
        battery: frequenz.api.microgrid.battery_pb2.Battery | None = ...,
        ev_charger: frequenz.api.microgrid.ev_charger_pb2.EVCharger | None = ...,
        sensor: frequenz.api.microgrid.sensor_pb2.Sensor | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["battery", b"battery", "data", b"data", "ev_charger", b"ev_charger", "inverter", b"inverter", "meter", b"meter", "sensor", b"sensor", "ts", b"ts"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["battery", b"battery", "data", b"data", "ev_charger", b"ev_charger", "id", b"id", "inverter", b"inverter", "meter", b"meter", "sensor", b"sensor", "ts", b"ts"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["data", b"data"]) -> typing_extensions.Literal["meter", "inverter", "battery", "ev_charger", "sensor"] | None: ...

global___ComponentData = ComponentData

class Connection(google.protobuf.message.Message):
    """Describes a single connection between components of the microgrid,
    with direction away from the grid endpoint, meaning it is aligned
    with positive current according to the passive sign convention:
    https://en.wikipedia.org/wiki/Passive_sign_convention
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    start: builtins.int
    """`id` of the component the connection starts from"""
    end: builtins.int
    """`id` of the component the connection points to"""
    def __init__(
        self,
        *,
        start: builtins.int = ...,
        end: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> None: ...

global___Connection = Connection

class ConnectionList(google.protobuf.message.Message):
    """List of connections between components"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONNECTIONS_FIELD_NUMBER: builtins.int
    @property
    def connections(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Connection]: ...
    def __init__(
        self,
        *,
        connections: collections.abc.Iterable[global___Connection] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["connections", b"connections"]) -> None: ...

global___ConnectionList = ConnectionList
