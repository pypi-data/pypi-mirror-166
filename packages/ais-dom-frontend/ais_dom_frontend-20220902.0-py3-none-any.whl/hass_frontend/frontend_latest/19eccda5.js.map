{"version":3,"file":"19eccda5.js","mappings":";AAwCA;;AAEA;AACA;;;AAkOA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAhBA;;AC1NA;;AAEA;AACA;AACA;;;AAKA;;AAEA;AACA;AACA;;AAKA;AACA;AAGA;AACA;AACA;AAGA;AAKA;AAJA;;;;;;;;;;;;;;;;AAjDA;;ACgCA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAGA;AACA;;AAEA;AACA;;;AAGA;AAGA;AACA;AACA;AACA;;;AAGA;AAGA;AACA;AACA;AACA;AACA;;;AA/DA;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AAoEA;;AApEA;;;;;;ACkBA;;;;AAKA;;;;;;;;;;;;;ACpBA;ACSA;AAGA;;;;;;;;;;;;;;;;;;;;ACZA;;ACkDA;;AAIA;AACA;AACA;AACA;;;AAKA;AAeA;AAKA;;AAGA;;AAGA;;AAGA;AACA;;;;AAQA;;AAMA;AACA;;;;;AAOA;;AAKA;;;;;;AAQA;;AAKA;;;;;;AASA;;;;;AAgCA;AACA;;;AAGA;;;AAIA;AACA;;;;;AAMA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAzJA","sources":["webpack://home-assistant-frontend/./src/components/device/ha-device-picker.ts","webpack://home-assistant-frontend/./src/components/entity/ha-entity-toggle.ts","webpack://home-assistant-frontend/./src/components/ha-button-related-filter-menu.ts","webpack://home-assistant-frontend/./src/components/ha-card.ts","webpack://home-assistant-frontend/./src/components/ha-fab.ts","webpack://home-assistant-frontend/./src/components/ha-formfield.ts","webpack://home-assistant-frontend/./src/components/ha-state-icon.ts","webpack://home-assistant-frontend/./src/components/ha-switch.ts","webpack://home-assistant-frontend/./src/panels/aistts/ha-panel-aisttsauto.ts"],"sourcesContent":["import \"@material/mwc-list/mwc-list-item\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"ha-device-picker\")\nexport class HaDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  /**\n   * Show only devices with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no devices with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only devices with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      let inputDevices = devices.filter(\n        (device) => device.id === this.value || !device.disabled_by\n      );\n\n      if (includeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices.filter(\n          (device) =>\n            // We always want to include the device of the current value\n            device.id === this.value || deviceFilter!(device)\n        );\n      }\n\n      const outputDevices = inputDevices.map((device) => ({\n        id: device.id,\n        name: computeDeviceName(\n          device,\n          this.hass,\n          deviceEntityLookup[device.id]\n        ),\n        area:\n          device.area_id && areaLookup[device.area_id]\n            ? areaLookup[device.area_id].name\n            : this.hass.localize(\"ui.components.device-picker.no_area\"),\n      }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\")\n      );\n    }\n  );\n\n  public open() {\n    this.comboBox?.open();\n  }\n\n  public focus() {\n    this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices;\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.devices || !this.areas || !this.entities) {\n      return html``;\n    }\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-device-picker\": HaDevicePicker;\n  }\n}\n","import { mdiFlash, mdiFlashOff } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { property, state } from \"lit/decorators\";\nimport { STATES_OFF } from \"../../common/const\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { UNAVAILABLE, UNAVAILABLE_STATES, UNKNOWN } from \"../../data/entity\";\nimport { forwardHaptic } from \"../../data/haptics\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-formfield\";\nimport \"../ha-icon-button\";\nimport \"../ha-switch\";\n\nconst isOn = (stateObj?: HassEntity) =>\n  stateObj !== undefined &&\n  !STATES_OFF.includes(stateObj.state) &&\n  !UNAVAILABLE_STATES.includes(stateObj.state);\n\nexport class HaEntityToggle extends LitElement {\n  // hass is not a property so that we only re-render on stateObj changes\n  public hass?: HomeAssistant;\n\n  @property() public stateObj?: HassEntity;\n\n  @property() public label?: string;\n\n  @state() private _isOn = false;\n\n  protected render(): TemplateResult {\n    if (!this.stateObj) {\n      return html` <ha-switch disabled></ha-switch> `;\n    }\n\n    if (\n      this.stateObj.attributes.assumed_state ||\n      this.stateObj.state === UNKNOWN\n    ) {\n      return html`\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} off`}\n          .path=${mdiFlashOff}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOff}\n          class=${!this._isOn && this.stateObj.state !== UNKNOWN\n            ? \"state-active\"\n            : \"\"}\n        ></ha-icon-button>\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} on`}\n          .path=${mdiFlash}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOn}\n          class=${this._isOn ? \"state-active\" : \"\"}\n        ></ha-icon-button>\n      `;\n    }\n\n    const switchTemplate = html`<ha-switch\n      aria-label=${`Toggle ${computeStateName(this.stateObj)} ${\n        this._isOn ? \"off\" : \"on\"\n      }`}\n      .checked=${this._isOn}\n      .disabled=${this.stateObj.state === UNAVAILABLE}\n      @change=${this._toggleChanged}\n    ></ha-switch>`;\n\n    if (!this.label) {\n      return switchTemplate;\n    }\n\n    return html`\n      <ha-formfield .label=${this.label}>${switchTemplate}</ha-formfield>\n    `;\n  }\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    this.addEventListener(\"click\", (ev) => ev.stopPropagation());\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"stateObj\")) {\n      this._isOn = isOn(this.stateObj);\n    }\n  }\n\n  private _toggleChanged(ev) {\n    const newVal = ev.target.checked;\n\n    if (newVal !== this._isOn) {\n      this._callService(newVal);\n    }\n  }\n\n  private _turnOn() {\n    this._callService(true);\n  }\n\n  private _turnOff() {\n    this._callService(false);\n  }\n\n  // We will force a re-render after a successful call to re-sync the toggle\n  // with the state. It will be out of sync if our service call did not\n  // result in the entity to be turned on. Since the state is not changing,\n  // the resync is not called automatic.\n  private async _callService(turnOn): Promise<void> {\n    if (!this.hass || !this.stateObj) {\n      return;\n    }\n    forwardHaptic(\"light\");\n    const stateDomain = computeStateDomain(this.stateObj);\n    let serviceDomain;\n    let service;\n\n    if (stateDomain === \"lock\") {\n      serviceDomain = \"lock\";\n      service = turnOn ? \"unlock\" : \"lock\";\n    } else if (stateDomain === \"cover\") {\n      serviceDomain = \"cover\";\n      service = turnOn ? \"open_cover\" : \"close_cover\";\n    } else if (stateDomain === \"group\") {\n      serviceDomain = \"homeassistant\";\n      service = turnOn ? \"turn_on\" : \"turn_off\";\n    } else {\n      serviceDomain = stateDomain;\n      service = turnOn ? \"turn_on\" : \"turn_off\";\n    }\n\n    const currentState = this.stateObj;\n\n    // Optimistic update.\n    this._isOn = turnOn;\n\n    await this.hass.callService(serviceDomain, service, {\n      entity_id: this.stateObj.entity_id,\n    });\n\n    setTimeout(async () => {\n      // If after 2 seconds we have not received a state update\n      // reset the switch to it's original state.\n      if (this.stateObj === currentState) {\n        this._isOn = isOn(this.stateObj);\n      }\n    }, 2000);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        white-space: nowrap;\n        min-width: 38px;\n      }\n      ha-icon-button {\n        --mdc-icon-button-size: 40px;\n        color: var(--ha-icon-button-inactive-color, var(--primary-text-color));\n        transition: color 0.5s;\n      }\n      ha-icon-button.state-active {\n        color: var(--ha-icon-button-active-color, var(--primary-color));\n      }\n      ha-switch {\n        padding: 13px 5px;\n      }\n    `;\n  }\n}\n\ncustomElements.define(\"ha-entity-toggle\", HaEntityToggle);\n","import type { Corner } from \"@material/mwc-menu\";\nimport \"@material/mwc-menu/mwc-menu-surface\";\nimport { mdiFilterVariant } from \"@mdi/js\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport { computeDeviceName } from \"../data/device_registry\";\nimport { findRelated, RelatedResult } from \"../data/search\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./device/ha-device-picker\";\nimport \"./entity/ha-entity-picker\";\nimport \"./ha-area-picker\";\nimport \"./ha-icon-button\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"related-changed\": {\n      value?: FilterValue;\n      items?: RelatedResult;\n      filter?: string;\n    };\n  }\n}\n\ninterface FilterValue {\n  area?: string;\n  device?: string;\n  entity?: string;\n}\n\n@customElement(\"ha-button-related-filter-menu\")\nexport class HaRelatedFilterButtonMenu extends LitElement {\n  @property() public hass!: HomeAssistant;\n\n  @property() public corner: Corner = \"TOP_START\";\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ attribute: false }) public value?: FilterValue;\n\n  /**\n   * Show no entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  @state() private _open = false;\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-icon-button\n        @click=${this._handleClick}\n        .label=${this.hass.localize(\"ui.components.related-filter-menu.filter\")}\n        .path=${mdiFilterVariant}\n      ></ha-icon-button>\n      <mwc-menu-surface\n        .open=${this._open}\n        .anchor=${this}\n        .fullwidth=${this.narrow}\n        .corner=${this.corner}\n        @closed=${this._onClosed}\n        @input=${stopPropagation}\n      >\n        <ha-area-picker\n          .label=${this.hass.localize(\n            \"ui.components.related-filter-menu.filter_by_area\"\n          )}\n          .hass=${this.hass}\n          .value=${this.value?.area}\n          no-add\n          @value-changed=${this._areaPicked}\n          @click=${this._preventDefault}\n        ></ha-area-picker>\n        <ha-device-picker\n          .label=${this.hass.localize(\n            \"ui.components.related-filter-menu.filter_by_device\"\n          )}\n          .hass=${this.hass}\n          .value=${this.value?.device}\n          @value-changed=${this._devicePicked}\n          @click=${this._preventDefault}\n        ></ha-device-picker>\n        <ha-entity-picker\n          .label=${this.hass.localize(\n            \"ui.components.related-filter-menu.filter_by_entity\"\n          )}\n          .hass=${this.hass}\n          .value=${this.value?.entity}\n          .excludeDomains=${this.excludeDomains}\n          @value-changed=${this._entityPicked}\n          @click=${this._preventDefault}\n        ></ha-entity-picker>\n      </mwc-menu-surface>\n    `;\n  }\n\n  private _handleClick(): void {\n    if (this.disabled) {\n      return;\n    }\n    this._open = true;\n  }\n\n  private _onClosed(ev): void {\n    ev.stopPropagation();\n    this._open = false;\n  }\n\n  private _preventDefault(ev) {\n    ev.preventDefault();\n  }\n\n  private async _entityPicked(ev: CustomEvent) {\n    ev.stopPropagation();\n    const entityId = ev.detail.value;\n    if (!entityId) {\n      fireEvent(this, \"related-changed\", { value: undefined });\n      return;\n    }\n    const filter = this.hass.localize(\n      \"ui.components.related-filter-menu.filtered_by_entity\",\n      \"entity_name\",\n      computeStateName((ev.currentTarget as any).comboBox.selectedItem)\n    );\n    const items = await findRelated(this.hass, \"entity\", entityId);\n    fireEvent(this, \"related-changed\", {\n      value: { entity: entityId },\n      filter,\n      items,\n    });\n  }\n\n  private async _devicePicked(ev: CustomEvent) {\n    ev.stopPropagation();\n    const deviceId = ev.detail.value;\n    if (!deviceId) {\n      fireEvent(this, \"related-changed\", { value: undefined });\n      return;\n    }\n    const filter = this.hass.localize(\n      \"ui.components.related-filter-menu.filtered_by_device\",\n      \"device_name\",\n      computeDeviceName(\n        (ev.currentTarget as any).comboBox.selectedItem,\n        this.hass\n      )\n    );\n    const items = await findRelated(this.hass, \"device\", deviceId);\n\n    fireEvent(this, \"related-changed\", {\n      value: { device: deviceId },\n      filter,\n      items,\n    });\n  }\n\n  private async _areaPicked(ev: CustomEvent) {\n    ev.stopPropagation();\n    const areaId = ev.detail.value;\n    if (!areaId) {\n      fireEvent(this, \"related-changed\", { value: undefined });\n      return;\n    }\n    const filter = this.hass.localize(\n      \"ui.components.related-filter-menu.filtered_by_area\",\n      \"area_name\",\n      (ev.currentTarget as any).comboBox.selectedItem.name\n    );\n    const items = await findRelated(this.hass, \"area\", areaId);\n    fireEvent(this, \"related-changed\", {\n      value: { area: areaId },\n      filter,\n      items,\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n        position: relative;\n        --mdc-menu-min-width: 250px;\n      }\n      ha-area-picker,\n      ha-device-picker,\n      ha-entity-picker {\n        display: block;\n        width: 300px;\n        padding: 4px 16px;\n        box-sizing: border-box;\n      }\n      ha-area-picker {\n        padding-top: 16px;\n      }\n      ha-entity-picker {\n        padding-bottom: 16px;\n      }\n      :host([narrow]) ha-area-picker,\n      :host([narrow]) ha-device-picker,\n      :host([narrow]) ha-entity-picker {\n        width: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-button-related-filter-menu\": HaRelatedFilterButtonMenu;\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-card\")\nexport class HaCard extends LitElement {\n  @property() public header?: string;\n\n  @property({ type: Boolean, reflect: true }) public outlined = false;\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        border-radius: var(--ha-card-border-radius, 4px);\n        box-shadow: var(\n          --ha-card-box-shadow,\n          0px 2px 1px -1px rgba(0, 0, 0, 0.2),\n          0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n          0px 1px 3px 0px rgba(0, 0, 0, 0.12)\n        );\n        color: var(--primary-text-color);\n        display: block;\n        transition: all 0.3s ease-out;\n        position: relative;\n      }\n\n      :host([outlined]) {\n        box-shadow: none;\n        border-width: var(--ha-card-border-width, 1px);\n        border-style: solid;\n        border-color: var(\n          --ha-card-border-color,\n          var(--divider-color, #e0e0e0)\n        );\n      }\n\n      .card-header,\n      :host ::slotted(.card-header) {\n        color: var(--ha-card-header-color, --primary-text-color);\n        font-family: var(--ha-card-header-font-family, inherit);\n        font-size: var(--ha-card-header-font-size, 24px);\n        letter-spacing: -0.012em;\n        line-height: 48px;\n        padding: 12px 16px 16px;\n        display: block;\n        margin-block-start: 0px;\n        margin-block-end: 0px;\n        font-weight: normal;\n      }\n\n      :host ::slotted(.card-content:not(:first-child)),\n      slot:not(:first-child)::slotted(.card-content) {\n        padding-top: 0px;\n        margin-top: -8px;\n      }\n\n      :host ::slotted(.card-content) {\n        padding: 16px;\n      }\n\n      :host ::slotted(.card-actions) {\n        border-top: 1px solid var(--divider-color, #e8e8e8);\n        padding: 5px 16px;\n      }\n    `;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.header\n        ? html`<h1 class=\"card-header\">${this.header}</h1>`\n        : html``}\n      <slot></slot>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-card\": HaCard;\n  }\n}\n","import { FabBase } from \"@material/mwc-fab/mwc-fab-base\";\nimport { styles } from \"@material/mwc-fab/mwc-fab.css\";\nimport { customElement } from \"lit/decorators\";\nimport { css } from \"lit\";\n\n@customElement(\"ha-fab\")\nexport class HaFab extends FabBase {\n  protected firstUpdated(changedProperties) {\n    super.firstUpdated(changedProperties);\n    this.style.setProperty(\"--mdc-theme-secondary\", \"var(--primary-color)\");\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host .mdc-fab--extended .mdc-fab__icon {\n        margin-inline-start: -8px;\n        margin-inline-end: 12px;\n        direction: var(--direction);\n      }\n    `,\n    // safari workaround - must be explicit\n    document.dir === \"rtl\"\n      ? css`\n          :host .mdc-fab--extended .mdc-fab__icon {\n            direction: rtl;\n          }\n        `\n      : css``,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-fab\": HaFab;\n  }\n}\n","import { FormfieldBase } from \"@material/mwc-formfield/mwc-formfield-base\";\nimport { styles } from \"@material/mwc-formfield/mwc-formfield.css\";\nimport { css } from \"lit\";\nimport { customElement } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\n\n@customElement(\"ha-formfield\")\nexport class HaFormfield extends FormfieldBase {\n  protected _labelClick() {\n    const input = this.input;\n    if (input) {\n      input.focus();\n      switch (input.tagName) {\n        case \"HA-CHECKBOX\":\n        case \"HA-RADIO\":\n          (input as any).checked = !(input as any).checked;\n          fireEvent(input, \"change\");\n          break;\n        default:\n          input.click();\n          break;\n      }\n    }\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host(:not([alignEnd])) ::slotted(ha-switch) {\n        margin-right: 10px;\n        margin-inline-end: 10px;\n        margin-inline-start: inline;\n      }\n      .mdc-form-field > label {\n        direction: var(--direction);\n        margin-inline-start: 0;\n        margin-inline-end: auto;\n        padding-inline-start: 4px;\n        padding-inline-end: 0;\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-formfield\": HaFormfield;\n  }\n}\n","import { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { stateIconPath } from \"../common/entity/state_icon_path\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-state-icon\")\nexport class HaStateIcon extends LitElement {\n  @property({ attribute: false }) public state?: HassEntity;\n\n  @property() public icon?: string;\n\n  protected render(): TemplateResult {\n    if (this.icon || this.state?.attributes.icon) {\n      return html`<ha-icon\n        .icon=${this.icon || this.state?.attributes.icon}\n      ></ha-icon>`;\n    }\n    return html`<ha-svg-icon .path=${stateIconPath(this.state)}></ha-svg-icon>`;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-state-icon\": HaStateIcon;\n  }\n}\n","import { SwitchBase } from \"@material/mwc-switch/deprecated/mwc-switch-base\";\nimport { styles } from \"@material/mwc-switch/deprecated/mwc-switch.css\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { forwardHaptic } from \"../data/haptics\";\n\n@customElement(\"ha-switch\")\nexport class HaSwitch extends SwitchBase {\n  // Generate a haptic vibration.\n  // Only set to true if the new value of the switch is applied right away when toggling.\n  // Do not add haptic when a user is required to press save.\n  @property({ type: Boolean }) public haptic = false;\n\n  protected firstUpdated() {\n    super.firstUpdated();\n    this.addEventListener(\"change\", () => {\n      if (this.haptic) {\n        forwardHaptic(\"light\");\n      }\n    });\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--switch-checked-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__thumb {\n        background-color: var(--switch-checked-button-color);\n        border-color: var(--switch-checked-button-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__track {\n        background-color: var(--switch-checked-track-color);\n        border-color: var(--switch-checked-track-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__thumb {\n        background-color: var(--switch-unchecked-button-color);\n        border-color: var(--switch-unchecked-button-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__track {\n        background-color: var(--switch-unchecked-track-color);\n        border-color: var(--switch-unchecked-track-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-switch\": HaSwitch;\n  }\n}\n","import \"../../components/ha-card\";\nimport \"../../components/ha-menu-button\";\nimport \"@material/mwc-icon-button\";\nimport {\n  mdiHistory,\n  mdiInformationOutline,\n  mdiPencil,\n  mdiElectricSwitch,\n} from \"@mdi/js\";\nimport \"@polymer/paper-tooltip/paper-tooltip\";\nimport { css, html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { property, customElement } from \"lit/decorators\";\nimport \"@polymer/polymer/lib/elements/dom-repeat\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { navigate } from \"../../common/navigate\";\nimport \"../../components/entity/ha-entity-toggle\";\nimport \"../../components/ha-fab\";\nimport \"../../components/ha-svg-icon\";\nimport \"../../components/ha-button-related-filter-menu\";\nimport { triggerAutomationActions } from \"../../data/automation\";\nimport { haStyle } from \"../../resources/styles\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { HomeAssistant } from \"../../types\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport memoizeOne from \"memoize-one\";\nimport { HassEntityBase } from \"home-assistant-js-websocket\";\nimport { HaCheckbox } from \"../../components/ha-checkbox\";\n// eslint-disable-next-line import/no-duplicates\nimport \"../../components/data-table/ha-data-table\";\nimport {\n  DataTableColumnContainer,\n  DataTableRowData,\n  // eslint-disable-next-line import/no-duplicates\n} from \"../../components/data-table/ha-data-table\";\n\nexport interface AutomationRowData extends DataTableRowData {\n  id: string;\n  name: string | undefined;\n  last_triggered: string;\n  entity: HassEntityBase;\n}\n\n@customElement(\"ha-panel-aisttsauto\")\nclass HaPanelAisTtsAuto extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public isWide!: boolean;\n\n  @property({ type: Boolean }) public narrow!: boolean;\n\n  private _columns = memoizeOne(\n    (narrow: boolean, _locale): DataTableColumnContainer => {\n      const columns: DataTableColumnContainer = {\n        toggle: {\n          title: html`&nbsp;&nbsp;&nbsp;&nbsp;<ha-svg-icon\n              path=${mdiElectricSwitch}\n            ></ha-svg-icon>`,\n          type: \"icon\",\n          template: (_toggle, automation: any) =>\n            html`\n              <ha-checkbox\n                .key=${automation.id}\n                .hass=${this.hass}\n                @change=${this._handleRowCheckboxClick}\n                .checked=${automation.entity.state === \"on\"}\n              >\n              </ha-checkbox>\n            `,\n        },\n        name: {\n          title: \"Nazwa\",\n          sortable: true,\n          filterable: true,\n          direction: \"asc\",\n          grows: true,\n        },\n      };\n\n      if (!narrow) {\n        columns.last_triggered = {\n          sortable: true,\n          width: \"20%\",\n          title: this.hass.localize(\"ui.card.automation.last_triggered\"),\n          template: (last_triggered) => html`\n            ${last_triggered\n              ? formatDateTime(new Date(last_triggered), this.hass.locale)\n              : this.hass.localize(\"ui.components.relative_time.never\")}\n          `,\n        };\n        columns.trigger = {\n          title: html`\n            <mwc-button style=\"visibility: hidden\">\n              ${this.hass.localize(\"ui.card.automation.trigger\")}\n            </mwc-button>\n          `,\n          width: \"20%\",\n          template: (_info, automation: any) => html`\n            <mwc-button\n              .automation=${automation.entity}\n              @click=${(ev) => this._runActions(ev)}\n            >\n              URUCHOM\n            </mwc-button>\n          `,\n        };\n      }\n\n      if (this.hass.user!.is_admin) {\n        columns.info = {\n          title: \"\",\n          type: \"icon-button\",\n          template: (_info, automation: any) => html`\n            <mwc-icon-button\n              .automation=${automation.entity}\n              @click=${this._showInfo}\n              label=\"Info\"\n            >\n              <ha-svg-icon .path=${mdiInformationOutline}></ha-svg-icon>\n            </mwc-icon-button>\n          `,\n        };\n        columns.trace = {\n          title: \"\",\n          type: \"icon-button\",\n          template: (_info, automation: any) => html`\n            <a\n              href=\"/config/automation/trace/${automation.entity.attributes.id}\"\n            >\n              <mwc-icon-button label=\"Åšlad\">\n                <ha-svg-icon .path=${mdiHistory}></ha-svg-icon>\n              </mwc-icon-button>\n            </a>\n          `,\n        };\n        columns.edit = {\n          title: \"\",\n          type: \"icon-button\",\n          template: (_info, automation: any) => html`\n            <a\n              href=\"/config/automation/edit/${automation.entity.attributes.id}\"\n            >\n              <mwc-icon-button label=\"Edit\">\n                <ha-svg-icon path=${mdiPencil}></ha-svg-icon>\n              </mwc-icon-button>\n            </a>\n          `,\n        };\n      }\n      return columns;\n    }\n  );\n\n  protected firstUpdated(changedProps: PropertyValues): void {\n    super.firstUpdated(changedProps);\n  }\n\n  private _get_automations(_states) {\n    const l_automation: AutomationRowData[] = [];\n    Object.values(this.hass.states).forEach((entity) => {\n      if (\n        computeStateDomain(entity) === \"automation\" &&\n        !entity.entity_id.startsWith(\"automation.ais_\")\n      ) {\n        l_automation.push({\n          id: entity.entity_id,\n          name: entity.attributes.friendly_name,\n          last_triggered: entity.attributes.last_triggered,\n          entity: entity,\n        });\n      }\n    });\n    return l_automation;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-app-layout>\n        <app-header slot=\"header\" fixed>\n          <app-toolbar>\n            <ha-menu-button\n              .hass=${this.hass}\n              .narrow=${this.narrow}\n            ></ha-menu-button>\n            <div main-title>TTS Automatyczny</div>\n            ${this.hass.user!.is_admin\n              ? html`<ha-icon-button\n                  label=\"Dodaj\"\n                  icon=\"hass:plus\"\n                  @click=${this._createNew}\n                ></ha-icon-button>`\n              : html``}\n          </app-toolbar>\n        </app-header>\n        <ha-card class=\"content\">\n          <ha-data-table\n            .columns=${this._columns(this.narrow, this.hass.locale)}\n            .data=${this._get_automations(this.hass.states)}\n            auto-height\n            searchLabel=\"Szukaj\"\n            noDataText=\"Brak danych\"\n          ></ha-data-table>\n        </ha-card>\n      </ha-app-layout>\n    `;\n  }\n\n  private _showInfo(ev) {\n    ev.stopPropagation();\n    const entityId = (ev.currentTarget as any).automation.entity_id;\n    fireEvent(this, \"hass-more-info\", { entityId });\n  }\n\n  private _runActions(ev) {\n    const entityId = (ev.currentTarget as any).automation.entity_id;\n    triggerAutomationActions(this.hass, entityId);\n  }\n\n  private _createNew() {\n    navigate(\"/config/automation/edit/new\");\n  }\n\n  private _handleRowCheckboxClick(ev: Event) {\n    const key = (ev.currentTarget as any).key;\n    const hass = (ev.currentTarget as any).hass;\n    const checkbox = ev.currentTarget as HaCheckbox;\n    let mode = \"off\";\n    if (checkbox.checked) {\n      mode = \"on\";\n    }\n    hass.callService(\"ais_tts\", \"change_auto_mode\", {\n      entity_id: key,\n      change_to: mode,\n    });\n  }\n\n  static get styles() {\n    return [\n      haStyle,\n      css`\n        ha-card.content {\n          padding: 16px;\n        }\n\n        .has-header {\n          padding-top: 0;\n        }\n\n        .checked span {\n          color: var(--primary-color);\n        }\n        .content {\n          padding-bottom: 32px;\n          max-width: 94%;\n          margin: 0 auto;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-panel-aisttsauto\": HaPanelAisTtsAuto;\n  }\n}\n"],"names":[],"sourceRoot":""}