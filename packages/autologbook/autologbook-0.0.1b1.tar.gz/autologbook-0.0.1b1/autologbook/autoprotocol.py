# -*- coding: utf-8 -*-
"""
Created on Wed May 11 08:37:49 2022

@author: Antonio Bulgheroni (antonio.bulgheroni@ec.europa.eu)


"""
import configparser
import logging
import os
import re
from datetime import datetime
# TODO: remove os.path and replace it with pathlib Path
from os.path import exists
from pathlib import Path

import elog
import markdown
import urllib3
import yaml
from PIL import Image
from PyQt5 import QtCore
from yattag import Doc, indent

from autologbook import autoconfig, autoerror, autotools

urllib3.disable_warnings()
Signal = QtCore.pyqtSignal
Slot = QtCore.pyqtSlot
log = logging.getLogger('__main__')


class SignalDispatcher(QtCore.QObject):
    """
    Signal Dispatcher class.

    An helper class to implement the Qt Signal / Slot mechanism for non Qt derived
    object.

    """

    added_element = Signal(str, str, str, name='added_element')
    removed_element = Signal(str, str, str, name='removed_element')


class HTMLObject(object):
    """
    Subclass of Object just able to generate HTML code.

    it contains only the three **variable** of the yattag package.

    """

    # the yattag for HTML code generation
    doc, tag, text, line = Doc().ttl()

    # used for the proper construction of the URLs
    baseRFolder = autoconfig.IMAGE_SERVER_BASE_PATH  # Path('R:\A226\Results')
    rootFolder = autoconfig.IMAGE_SERVER_ROOT_URL  # 'https://10.166.16.24/micro'

    def convertPath2URI(self, path):
        """
        Convert a path to a URI.

        This utility takes an input path and it manipulates it in order to obtain
        a valid URL.

        First it removes the IMAGE_SERVER_BASE_PATH and replaces it with the
        IMAGE_SERVER_ROOT_URL (both values are taken from the autoconfig constants)
        and then it replaces all back-slashes with normal slashes.

        Parameters
        ----------
        path : Path-like object or string
            The input path to be converted.

        Returns
        -------
        url : URL
            The URL generated by the conversion.

        """
        p = Path(path)
        p_str = str(p)
        url = p_str.replace(str(self.baseRFolder), str(
            self.rootFolder)).replace('\\', '/')
        return url

    def printHTML(self, indentation=True):
        """
        Print the HTML content.

        Parameters
        ----------
        indentation : BOOL, optional
            Set to True to have indentation in the output (good for humans)
            Set to False for a plain and compact out (good for file).

        Returns
        -------
        Return a string of HTML

        """
        if indentation:
            return indent(self.doc.getvalue(), indentation='\t',
                          newline='\r\n', indent_text=True)
        else:
            return self.doc.getvalue()

    def saveHTML2File(self, filename, indentation=False):
        """
        Save th HTML to a file.

        Parameters
        ----------
        filename : File-like object
            The target file name
        indentation : BOOL, optional
            Set to True to have indentation in the output (good for humans)
            Set to False for a plain and compact out (good for file).

        Returns
        -------
        None.

        """
        log.debug('Saving HTML to file %s' % filename)
        with open(filename, 'w', encoding='utf-8') as fp:
            fp.write(self.printHTML(indentation))

    @classmethod
    def resetHTMLContent(cls):
        """
        Reset the HTML Content of the YATTAG doc.

        Returns
        -------
        None.

        """
        log.debug('Resetting the HTML Content')
        cls.doc, cls.tag, cls.text, cls.line = Doc().ttl()


class Protocol(HTMLObject):
    """
    The basic protocol class.

    it contains:
        - an empty list of samples
        - an empty list of attachments
        - a protocol number
        - a project name
        - a project responsible

    """

    def __init__(self, path, protocol=None, project=None, responsible=None):
        r"""
        Generate an instance of Protocol.

        It creates and initialize all instance variables of a Protocol,
        in particular the path that is where the all files will be living,
        and the three *ownership* variables, i.e. the protocol number,
        the project name and the responsible person.

        The *ownership variables* are normally retrieved from the path if it
        follows the standard naming convention (see path for the regular
        expression pattern), but they can also be overwritten if explicitly
        specified here.

        Parameters
        ----------
        path : str or path object
            The full path where the protocol is living.
            In order to retrieve the *ownership* variable automatically the path
            should look like these two examples:
                12458-Project-Responsible
                12458_Project_Responsible
            The regular expression pattern being used is the following:
                '^#*([\\d]+)\\s*[-_]\\s*([\\w\\W]+)\\s*[-_]\\s*([\\w\\W]+)$'
        protocol : int or string, optional
            The protocol number. This field is used to identy the analysis inside
            the logbook and of course it must unique. There is no unicity test
            performed here, but it should be done somewhere else.
            When the user wants to have the protocol number guessed from the path
            then, set this variable to None.
            The default is None.
            TODO: Implement a unicity check on the protocol number.
        project : string, optional
            The project name. As for the protocol number (see above), this is
            generally provided with the path.
            The default is None.
        responsible : string, optional
            The name of the responsible person. As for the protocol number (see above),
            this is generally provided with the path.
            The default is None.


        Raises
        ------
        autoerror.MissingProtocolInformation
            This exception is raised if the user did not provided customized
            ownership variables and the automatic guessing from the path
            was failing.

        Returns
        -------
        None.

        """
        HTMLObject.__init__(self)

        if not isinstance(path, Path):
            path = Path(path)

        skipGuessing = False
        if protocol is not None and project is not None and responsible is not None:
            # the user wants to use its own variables
            skipGuessing = True
            self.protocol = protocol
            self.project = project
            self.responsible = responsible

        self.path = Path(path)

        if not skipGuessing:
            # the user didn't provide his custom ownership variables.
            # we need to guess them from the path.
            folder = self.path.parts[-1]
            pattern = '^#*([\\d]+)\\s*[-_]\\s*([\\w\\W]+)\\s*[-_]\\s*([\\w\\W]+)$'
            match = re.search(pattern, folder)

            if match:
                self.protocol = match.group(1)
                self.project = match.group(2)
                self.responsible = match.group(3)
            else:
                err_msg = '''
                Ownership variables not provided and not availale in the path
                '''
                raise autoerror.MissingProtocolInformation(err_msg)

        log.info('Created a new Protocol (#={}, Project={}, Responsible={})'
                 .format(self.protocol, self.project, self.responsible))

        # initialize empty list for attachments and samples.
        self.attachments = []
        # in the case of samples it must be a dictionary.
        self.samples = {}

        # initialize the patterns and the exclusion patterns
        self.patterns = ['*.tif*', '*.yaml', '*.yml']
        self.excludedPatterns = []

        # a signal dispatcher
        self.signal_dispatcher = SignalDispatcher()

        # ordered sample list
        self.ordered_sample_list = []

        # reset the picture ID liss
        MicroscopePicture._reset_ids()

    def __str__(self):
        """Return basic string representation of a Protocol."""
        msg = (
            f'Protocol #{self.protocol} - {self.project} - {self.responsible}\n')
        if len(self.samples) == 0:
            msg += 'with no samples\n'
        elif len(self.samples) == 1:
            msg += 'with 1 sample\n'
        else:
            f'with {len(self.samples)}.\n'
        if len(self.samples):
            msg += ('\n'
                    'Sample list:\n\n')
        for sample in self.samples:
            msg += self.samples[sample].__str__()
            msg += '\n'

        return msg

    def emit_added(self, element_type, element_name, parent_name):
        """
        Emit a signal for the addition of a given element to the protocol.

        This method implments an interface to the Qt Signal / Slot mechanism.
        Every time a new element is added to the protocol, this method should be
        called in order to make the GUI aware of the changes, in particular
        the TreeViewModel where the whole protocol is described.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being added.
            The following values are implemented:
                - MicroPic: a MicroscopePicture
                - NavPic: a NavigationPicture
                - Sample: a Sample.
        element_name : String
            In the case of MicroPic and NavPic, the element_name must be the
            full path of the newly added element.
            In the case of Sample, the element_name is exactly the sample name
        parent_name : String
            In the case of NavPic, the parent_name is totally optional because
            all navigation images will be added to the 'Navigation Images' section.
            In the case of MicroPic, the parent_name is the sample name.
            In the case of Sample, the parent_name the name of the parent sample or 'Samples' if it is a top level sample.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.added_element.emit(
            element_type, element_name, parent_name)

    def emit_removed(self, element_type, element_name, parent_name):
        """
        Emit a signal for the removal of a given element from the protocol.

        This method implments an interface to the Qt Signal / Slot mechanism.
        Every time an element is removed from the protocol, this method should be
        called in order to make the GUI aware of the changes, in particular
        the TreeViewModel where the whole protocol is described.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being removed.
            The following values are implemented:
                - MicroPic: a MicroscopePicture
                - NavPic: a NavigationPicture
                - Sample: a Sample.
        element_name : String
            In the case of MicroPic and NavPic, the element_name must be the
            full path of the removed element.
            In the case of Sample, the element_name is exactly the sample name
        parent_name : String
            In the case of NavPic, the parent_name is totally optional because
            all navigation images are located in the 'Navigation Images' section.
            In the case of MicroPic, the parent_name is the sample name.
            In the case of Sample, the parent_name the name of the parent sample or
            'Samples' if it is a top level sample.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.removed_element.emit(
            element_type, element_name, parent_name)

    def getPatterns(self):
        """
        Return the interesting patterns for the watchdog.

        Each type of logbook has its own list of patterns and ignore patterns

        Returns
        -------
        None.

        """
        return self.patterns

    def getExcludedPatterns(self):
        """
        Return the excluded patterns for the watchdog.

        Each type of logbook has its own list of patterns and ignore patterns

        Returns
        -------
        None.

        """
        return self.excludedPatterns

    def addAttachment(self, attachment_path):
        """
        Add an attachment at the Protocol.

        Parameters
        ----------
        attachment_path : PATH | string
            The path of the attachment file.

        Returns
        -------
        None.

        """
        self.attachments.append(attachment_path)
        log.info('Added {} to the attachment list'.format(
            os.path.split(attachment_path)[-1]))
        log.debug('New attachment full path is {}'.format(attachment_path))
        log.debug('At the moment there are {} attachments in the list'.format(
            len(self.attachments)))

    def removeAttachment(self, attachment_path):
        """
        Remove one attachment.

        Parameters
        ----------
        attachment_path : Path | String
            The path of the attachment file

        Returns
        -------
        None.

        """
        if attachment_path in self.attachments:
            self.attachments.remove(attachment_path)
            log.info('Removed {} to the attachment list'.format(
                os.path.split(attachment_path)[-1]))
            log.debug('Removed attachment full path is {}'.format(
                attachment_path))
            log.debug('At the moment there are {} attachments in the list'.format(
                len(self.attachments)))
        else:
            log.warning('Attempt to remove {} from the attachments list, but it was not there'.format(
                os.path.split(attachment_path)[-1]))

    def addSample(self, sample):
        """
        Add a new sample to the protocol.

        The sample name is guessed from the folder


        Parameters
        ----------
        sample : autologbook.Sample
            This is an instance of the autologbook.Sample.

        Returns
        -------
        None.

        """
        if sample.full_name in self.samples:
            log.warning('Trying to add an existing sample (%s)' % sample.name)
            # it is a situation that should never happen since the filesystem is 
            # not allowing to have two directories with the same name 
            # but in case, here we raise the error.
            raise autoerror.SampleNameAlreadyExisting
            

        # add the sample to the dictionary using the full name as key. 
        # this should avoid problems with subsamples having the same names.
        self.samples[sample.full_name] = sample
        
        # the parent name is again a full_name or None if the current sample
        # is a top level sample. 
        #
        # for the protocol editor we need to pass Samples in case of a top level
        # sample or the whole hierarchy.
        parent = sample.parent
        if parent is None:
            parent_name = 'Samples'
        else:
            parent_name = parent
            
            # make the parent sample aware that he got a child!
            if parent_name in self.samples:
                self.samples[parent_name].addSubSample(sample.full_name)
            else:
                raise autoerror.ParentSampleError(f'Sample {sample.full_name} has a parent ({parent_name})'
                                                  ' not existing in protocol sample list.')

        self.emit_added('Sample', sample.full_name, parent_name)
        sample.signal_dispatcher.added_element.connect(
            self.signal_dispatcher.added_element)
        sample.signal_dispatcher.removed_element.connect(
            self.signal_dispatcher.removed_element)
        if parent is None:
            log.info('Added %s to the sample list' % (sample.full_name))
        else:
            log.info('Added %s to the sample list under %s' %
                     (sample.last_name, parent_name))
        log.debug('At the moment there are %s samples in the list' % (
            len(self.samples)))

    def removeSample(self, sample_full_name):
        """
        Remove one sample.

        Parameters
        ----------
        sample : str
            This is the sample full name

        Returns
        -------
        None.

        """
        if sample_full_name in self.samples:
            if self.samples[sample_full_name].parent:
                parent_name = self.samples[sample_full_name].parent
                log.debug('Removing subsample %s from its parent %s'
                          % (sample_full_name, parent_name))
                self.samples[parent_name].removeSubSample(sample_full_name)
                log.debug('Those are the remaining subsamples of %s'
                          % parent_name)
                for ssample in self.samples[parent_name].subsamples:
                    log.debug('-> %s' % ssample)
            else:
                parent_name = 'Samples'
            self.emit_removed('Sample', sample_full_name, parent_name)
            del self.samples[sample_full_name]
            log.info('Removed %s from the sample list' % (sample_full_name))
            log.debug('At the moment there are {} samples in the list'.format(
                len(self.samples)))
        else:
            log.warning(
                'Attempt to remove %s from the sample list, but it was not there' %(sample_full_name))

    def generateCustomHTML(self, mainkey):
        """
        Generate custom HTML.

        Helper function to generate customized HTML code for a given section.
        The section is identified by the mainkey parameter.

        The user can provide via the YAML customization file or the GUI, additional
        test (markdown formatted) to be added to each section of the protocol.

        Parameters
        ----------
        mainkey : string
            The section of the HTML for which the customized HTML is being
            generated.

        Returns
        -------
        None.

        """
        subkey = 'Description'
        exkey = 'Extra'
        if mainkey in self.yamlDict.keys() and self.yamlDict[mainkey]:
            if subkey in self.yamlDict[mainkey].keys() and self.yamlDict[mainkey][subkey]:
                self.doc.asis(markdown.markdown(
                    self.yamlDict[mainkey][subkey]))
            if exkey in self.yamlDict[mainkey].keys():
                if self.yamlDict[mainkey][exkey]:
                    if len(self.yamlDict[mainkey][exkey]) > 0:
                        self.line('h3', 'Additional information')
                        self.doc.asis(markdown.markdown(
                            self.yamlDict[mainkey][exkey]))

    def generateHTML(self):
        """
        Generate the HTML code for the protocol.

        This function is calling a similar function for each of the main sections
        of the protocol.
            1. Introduction
            2. Samples
            3. Closure

        Returns
        -------
        None.

        """
        log.info('Generating HTML code for protocol {}'.format(self.protocol))
        self.sanityCheck()
        self.generateHTMLIntro()
        self.generateHTMLSamples()
        self.generateHTMLClosure()

    def generateHTMLIntro(self):
        """
        Generate the introduction for the HTML output.

        It generates the following:
            1. The protocol title
            2. The customized introduction part
            3. The sample list

        Returns
        -------
        None.

        """
        log.debug('Generating HTML intro of protocol {}'.format(self.protocol))
        self.line('h1', 'Analysis protocol {}'.format(self.protocol),
                  style='text-align: center;', id='intro')
        self.generateCustomHTML('Introduction')

        # generate sample list
        self.generateHTMLSampleList()

    def generateHTMLSampleList(self):
        """
        Generate HTML Sample list.

        Generate a list with all the samples found in the protocol

        Returns
        -------
        None.

        """
        self.ordered_sample_list = []
        self.generateCustomHTML('Samples')
        log.debug('Generating HTML sample list')
        if len(self.samples):
            self.line(
                'h2', 'This analysis contains the following samples:', id='samplelist')
            with self.tag('ul'):
                # the key is the full_name
                for full_name, sample in self.samples.items():
                    if sample.parent is None:
                        # add this sample to the ordered sample list
                        self.ordered_sample_list.append(full_name)
                        with self.tag('li'):
                            with self.tag('a', href=f'#{full_name}'):
                                self.text(full_name)
                            if len(sample.images):
                                self.text(f' with {len(sample.images)} images')
                            if len(sample.subsamples):
                                self.generateHTMLSubSamplelistRecursively(
                                    sample.subsamples)

    def generateHTMLSubSamplelistRecursively(self, sample_list):
        """
        Generate the HTML for the sub sample list.

        In order to generate a nested bullet list of subsample this function
        is called for all top level samples.

        Parameters
        ----------
        sample_list : list
            A list of samples for which the HTML code has to be generated.

        Returns
        -------
        None.

        """
        with self.tag('ul'):
            # sample_name is a full_name
            for sample_name in sample_list:
                self.ordered_sample_list.append(sample_name)
                sample = self.samples[sample_name]
                with self.tag('li'):
                    with self.tag('a', href=f'#{sample_name}'):
                        self.text(self.samples[sample_name].last_name)
                    if len(sample.images):
                        self.text(f' with {len(sample.images)} images')
                    if len(sample.subsamples):
                        self.generateHTMLSubSamplelistRecursively(
                            sample.subsamples)

    def sanityCheck(self):
        """
        Perform a sanity check on the protocol.

        When several images are added and removed quickly it is possible that
        the sample, subsample structure gets corrupted.

        This method along with the private _checkSubSamples goes through all
        registered samples and subsamples.

        TODO: this method can be improved.

        Returns
        -------
        None.

        """
        for full_name, sample in self.samples.items():
            if sample.parent is None:
                self._checkSubSamples(sample.subsamples, sample)

    def _checkSubSamples(self, sample_list, parent):
        for full_name in sample_list:
            if full_name not in self.samples:
                parent.subsamples.remove(full_name)
            else:
                if len(self.samples[full_name].subsamples) != 0:
                    self._checkSubSamples(
                        self.samples[full_name].subsamples, self.samples[full_name])

    def getSampleHierarchy(self, sample):
        """
        Return the sample full name.
        
        Left here for compatibility reasons.
        
        Returns
        -------
        sample_full_name: str
            The sample full name.

        """
        return sample.full_name

    def generateHTMLSamples(self):
        """
        Generate the HTML code of the Samples section.

        If there are no samples, then it prints a no samples found message and quit.
        Otherwise, it prints a table with all the images for each of the samples.

        The HTML code generation for each image is done by the
        MicroscopePicture.generateHTMLCode method.

        Returns
        -------
        None.

        """
        if len(self.samples) == 0:
            self.doc.stag('hr')
            message = 'No samples found for this protocol'
            self.line('h2', message)
            log.debug(message)
            
        # the ordered_sample_list contains sample full names
        for full_name in self.ordered_sample_list:
            if full_name not in self.samples:
                continue
            sample = self.samples[full_name]

            if len(sample.images) == 0:
                self.doc.stag('hr')
                message = f'No microscope pictures found for {full_name}'
                self.line('h2', message, id=full_name)
                self.generateCustomHTML(full_name)
                log.debug(message)
            else:
                with self.tag('p'):
                    self.doc.stag('hr')
                self.line(
                    'h2', f'Picture list for sample: {full_name}', id=full_name)
                self.generateCustomHTML(full_name)
                log.debug('Generating HTML code for sample %s' % full_name)
                self.line('a', 'Hide / show the picture list',
                          onclick=f'hideDiv(\'{full_name}table\')', href='javascript:void(0);')
                with self.tag('table', border=1, cellpaggind=1, cellspacing=1,
                              style='display:table; width:1200px; border-collapse:collapse',
                              id=f'{full_name}table'):
                    with self.tag('tbody'):
                        for key, image in sample.images.items():

                            if image.getID() in self.yamlDict:

                                ydict = self.yamlDict[image.getID()]
                            elif int(image.getID()) in self.yamlDict:
                                ydict = self.yamlDict[int(image.getID())]
                            else:
                                ydict = {}
                            image.generateHTMLCode(ydict)
                self.doc.stag('br')
                self.line('a', 'Go back to the sample list',
                          href='#samplelist')
                self.doc.stag('br')
                self.line('a', 'Go back home', href='#intro')

    def generateHTMLClosure(self):
        """
        Generate the HTML code for the closure of the protocol.

        It is useful to add here all javascript that needs to be referred from
        page elements.

        Returns
        -------
        None.

        """
        # it makes sense to generate a conclusion title only if there is some
        # custom conclusion text.
        mainkey = 'Conclusion' 
        if mainkey in self.yamlDict.keys() and self.yamlDict[mainkey]:
            self.line('h1', 'Conclusion', style='text-align: center;', id='conclusion')
            self.generateCustomHTML(mainkey)
            
        # add all scripts for sure
        with self.tag('script'):
            self.doc.asis('''
                          function hideDiv(div_name) {
                              var x = document.getElementById(div_name);
                              if (x.style.display == "none") {
                                      x.style.display = "table";
                              } else {
                                  x.style.display = "none" ;
                             }
                         }
                        ''')


class ELOGProtocol(Protocol):
    """Subclass of Protocol having information about ELOG."""

    def __init__(self, path, elog_hostname, elog_port, elog_user, elog_password,
                 elog_use_ssl=True, elog_logbook=None, protocol=None,
                 project=None, responsible=None):
        Protocol.__init__(self, path, protocol, project, responsible)
        self.elog_hostname = elog_hostname
        self.elog_port = elog_port
        self.elog_user = elog_user
        self.elog_password = elog_password
        self.elog_use_ssl = elog_use_ssl
        self.elog_logbook = elog_logbook

        # initialize the yaml engine for HTML customization
        self.initializeYAML()

        # initialize an empty dictionary for the ELOG attributes
        self.attributes = {}

        # set the elog instance to null
        self.elog_instance = ''

    def initializeYAML(self):
        """
        Initialize the YAML customization tool.

        It looks for a yaml file in the protocol folder named according to the
        rule protocol-xxxxx.yaml where xxxxx is the protocol-id.

        If none is found than a new empty one is created, otherwise it is safely
        loaded and its content transferred to the yamlDict

        Returns
        -------
        None.

        """
        # initializie the yamlDict
        self.yamlDict = {}

        # let's assume that there 1 yaml file named protocol-123456.yaml
        self.yamlFilename = Path(self.path) / \
            Path('protocol-%s.yaml' % self.protocol)
        if not self.yamlFilename.exists():
            log.info('No yaml file found, copying an empty one')
            with open(self.yamlFilename, 'w', encoding='utf-8') as file:
                file.write('#empty yaml file')

        with open(self.yamlFilename, 'rt', encoding='utf-8') as file:
            self.yamlDict = yaml.safe_load(file)
            if not self.yamlDict:
                # the file might be empty, then we need to set is as a dictionary
                self.yamlDict = {}
        log.info('Loaded yaml file %s' % self.yamlFilename.name)

    def remove_from_yaml(self, key, force_dump=False):
        """
        Remove an element from the YAML customization dictionary.

        This method looks if element is present in the YAML dictionary.
        If so, it deletes it, otherwise simply return

        Parameters
        ----------
        key : string
            The key of the element to be removed from the yaml dictionary

        Returns
        -------
        None.

        """
        if key in self.yamlDict:
            del(self.yamlDict[key])
            log.debug('Removed %s from the yaml dictionary' % key)
            if force_dump:
                autotools.dump_yaml_file(self.yamlDict, self.yamlFilename)

    def removeSample(self, sample):
        """
        Remove Sample overload.

        This overload method just implement the removal from the yaml
        customization dictionary.

        Parameters
        ----------
        sample : string
            Sample name to be removed.

        Returns
        -------
        None.

        """
        super().removeSample(sample)
        self.remove_from_yaml(sample)

    def connect2ELOG(self):
        """
        Connect to the ELOG.

        This method is calling the elog.open function to generate an instance
        to the elog protocol.

        The elog.open itself is not checking whether the connection is valid or not,
        so to be sure we are actually getting a valid elog_instance, a real query to
        the elog (get_message_ids) is also performed.

        Returns
        -------
        elog_instance
            The elog_instance to be used to query the elog. The same value is
            also stored as an instance parameter

        """
        if self.elog_instance:
            return self.elog_instance
        log.info('Establishing connection with the eLOG server')
        try:
            self.elog_instance = elog.open(
                hostname=self.elog_hostname,
                port=self.elog_port,
                user=self.elog_user,
                password=self.elog_password,
                use_ssl=self.elog_use_ssl,
                logbook=self.elog_logbook,
                encrypt_pwd=False
            )
            # the elog open doens't check if the connection is ok
            # while the get message_ids perform a real connection
            # TODO: find a better way to test if the connection is valid.
            #       this is probably to be done in the elog package.

            self.elog_instance.get_message_ids()
            log.info('Connection to the eLOG server successfully established')
            return self.elog_instance
        except elog.LogbookAuthenticationError:
            log.critical('Logbook Authentication Error')
        except Exception as err:
            log.critical(
                'Unable to establish a connection with the eLOG server. Here is the returned error message.' + err)

    def postELOGMessage(self, skipAttachements=False):
        """
        Post the protocol to the ELOG server.

        This method will do the following:
            1. Attempt a connection to the elog server
            2. Check if other entries with the same protocol number exist.
                2.1 If yes and if it is one, just delete it.
                2.2 If no, just go ahead.
                2.3 If yes and they are many, then raise an exception.
            3. Post a new entry with all the required attributes and the HTML
               content.


        Parameters
        ----------
        skipAttachements : Bool, optional
            Decide whether to post also attachment or not.
            Posting attachments maybe bandwidth heavy and it makes no sense
            while updating the protocol during the analysis. It is only meaningfull
            at the end of the analysis.
            The default is False.

        Raises
        ------
        NameError
            Exception raised when more than one entries with the same protocol
            number is found already existing in the elog.

        Returns
        -------
        None.

        """
        if not self.elog_instance:
            self.connect2ELOG()
        # check if an entry with the same protocol id already exists
        protocol_ids = self.elog_instance.search(
            {'Protocol ID': self.protocol})
        
        real_ids = []
        for id in protocol_ids:
            log.debug('Entry %s with protocol %s' % (id, self.protocol))
            message, attributes, attchments = self.elog_instance.read(id)
            if attributes['Protocol ID'] == self.protocol:
                real_ids.append(id)
        
        log.debug('Searching for IDs with %s' % self.protocol)
        if (len(real_ids)) > 1:
            # there are more than 1 entry with this protocol ID.
            # It is a problem. Ask the user what to do.
            # TODO: implement this situation
            log.warn(
                'Several protocols with the same IDs have been found %s' %len(real_ids))
            raise NameError

        # if an entry already exists, try to see if we are allowed to edit it
        
        if real_ids:                       
            try:
                self.elog_instance.delete(real_ids[0])
                log.debug('Found already an eLog entry with protocol %s. Deleting it' %
                    self.protocol)
            except elog.logbook_exceptions.LogbookError as e:
                log.exception('Logbook error', e)
                    
        attachments = []
        if skipAttachements:
            attachments = []
        else:
            # please load only not empty attachments.
            for att in self.attachments:
                if os.stat(att).st_size:
                    attachments.append(att)
        try:
            self.elog_instance.post(self.printHTML(
                False), reply=False, attributes=self.attributes, attachments=attachments, encoding='HTML')
            log.info('Posting eLog entry for protocol {}'.format(self.protocol))
        except elog.LogbookAuthenticationError as e:
            log.exception('Logbook error', e)
        except elog.LogbookMessageRejected:
            log.critical(
                'ELOG Message too large, please split the project in subparts!')
            log.critical(
                'This operation must be done manually. Just rename this project as')
            log.critical('   %s-p1-%s-%s' %
                         (self.protocol, self.project, self.responsible))
            log.critical('and create another one as')
            log.critical('   %s-p2-%s-%s' %
                         (self.protocol, self.project, self.responsible))


class QuattroELOGProtocol(ELOGProtocol):
    """
    Subclass of the ELOGProtocol dedicated to the Quattro Microscope.

    This subclass implements all the specificities of the Quattro in particular
    the presence of navigation camera images.

    """

    def __init__(self, path, elog_hostname, elog_port, elog_user, elog_password,
                 elog_use_ssl=True, elog_logbook=autoconfig.QUATTRO_LOGBOOK,
                 protocol=None, project=None, responsible=None):

        ELOGProtocol.__init__(self, path, elog_hostname, elog_port, elog_user,
                              elog_password, elog_use_ssl,
                              elog_logbook, protocol, project, responsible)
        self.navcamimages = []
        self.attributes = {
            'Protocol ID': self.protocol,
            'Project': self.project,
            'Customer': self.responsible,
            'Operator': elog_user,
            'Creation date': datetime.today().timestamp(), 
            'Edit Lock' : 'Unprotected'
        }
        self.patterns.append('*NavCam*')  # add support for navcam images
        self.patterns.append('*.pdf')  # add support for pdf reports

        # exclude thumbnail and converted images
        self.excludedPatterns.append('png/*png')

        # exclude cropped images
        self.excludedPatterns.append('crop/*crop.tif*')

    def generateHTMLIntro(self):
        """
        Overload the standard HTML introduction.

        This overloaded method allows to implement the specific HTML introduction
        for the Quattro microscope.

        It prints the following:
            1. Protocol Title
            2. Customized introduction taken from the YAML file
            3. Sample list
            4. Navigation camera section

        """
        log.debug('Generating HTML intro for protocol {}'.format(self.protocol))
        self.line('h1', 'Quattro SEM Analysis protocol {}'.format(
            self.protocol), style="text-align:center;", id='intro')
        self.generateCustomHTML('Introduction')
        self.generateHTMLSampleList()
        self.generateHTMLNavCam()

    def generateHTMLNavCam(self):
        """
        Generate the HTML code for the Navigation camera section.

        It prints the following:
            1. Section title if at least one navigation image is provided.
            2. Custom text provided via the YAML file
            3. A single column table with a navigation image per line


        Returns
        -------
        None.

        """
        log.debug('Generating HTML code for the navigation camera images of protocol {}'.format(
            self.protocol))
        if len(self.navcamimages) == 0:
            log.debug('No navigation picture provided!')
            self.line('h2', 'No navigation picture provided!')
        else:
            self.line('h2', 'Navigation Camera image(s)')
            self.generateCustomHTML('Navigation images')

            with self.tag('table', align='left', border='1', cellpadding='1', cellspacing='1',
                          style='float:none;width:%spx; border-collapse:collapse' % autoconfig.IMAGE_NAVIGATION_MAX_WIDTH):
                with self.tag('tbody'):
                    for navcamimage in self.navcamimages:
                        with self.tag('tr'):
                            with self.tag('td'):
                                with self.tag('p', style='text-align-center'):
                                    with self.tag('figure', klass='image'):
                                        with self.tag('figure'):
                                            with self.tag('a', href=self.convertPath2URI(navcamimage)):
                                                self.doc.stag('img', width=autoconfig.IMAGE_NAVIGATION_MAX_WIDTH - 10,
                                                              alt=os.path.split(
                                                                  navcamimage)[-1],
                                                              src=self.convertPath2URI(navcamimage))

                                            caption = os.path.split(
                                                navcamimage)[-1]
                                            if os.path.split(navcamimage)[-1] in self.yamlDict and self.yamlDict[os.path.split(navcamimage)[-1]]:
                                                if 'Caption' in self.yamlDict[os.path.split(navcamimage)[-1]]:
                                                    caption = self.yamlDict[os.path.split(
                                                        navcamimage)[-1]]['Caption']
                                            self.line('figcaption', caption)
                                self.generateCustomHTML(
                                    os.path.split(navcamimage)[-1])

    def addNavCam(self, path):
        """
        Add a navigation camera image at the Protocol.

        Parameters
        ----------
        path : path-like | string
            The path of the navigation image file.

        Returns
        -------
        None.

        """
        self.navcamimages.append(path)
        log.info('Added {} to the navcam list'.format(path))
        log.debug('At the moment there are {} pictures in the navcam list'.format(
            len(self.navcamimages)))
        self.emit_added('NavPic', str(path), 'Navigation Images')

    def removeNavCam(self, path):
        """
        Remove one navigation camera image file.

        The navigation camera is also removed from the YAML customization
        dictionary if it was present.

        Parameters
        ----------
        path : Path | String
            The path of the navigation image file.

        Returns
        -------
        None.

        """
        if path in self.navcamimages:
            self.navcamimages.remove(path)
            log.info('Removed {} to the navcam list'.format(path))
            log.debug('At the moment there are {} pictures in the navcam list'.format(
                len(self.navcamimages)))
            self.emit_removed('NavCam', path, 'Navigation Images')
            self.remove_from_yaml(path)
        else:
            log.warning(
                'Attempt to remove {} from the navcam list, but it was not there'.format(path))


class VersaELOGProtocol(ELOGProtocol):
    """
    Subclass of the ELOGProtocol dedicated to the Versa Microscope.

    This subclass implements all the specificities of the Versa in particular
    the presence of navigation camera images.

    """

    def __init__(self, path, elog_hostname, elog_port, elog_user, elog_password,
                 elog_use_ssl=True, elog_logbook=autoconfig.VERSA_LOGBOOK,
                 protocol=None, project=None, responsible=None):

        ELOGProtocol.__init__(self, path, elog_hostname, elog_port, elog_user,
                              elog_password, elog_use_ssl, elog_logbook,
                              protocol, project, responsible)
        self.attributes = {
            'Protocol ID': self.protocol,
            'Project': self.project,
            'Customer': self.responsible,
            'Operator': elog_user,
            'Creation date': datetime.today().timestamp(),
            'Edit Lock' : 'Unprotected'
            
        }
        self.patterns.append('*.pdf')  # add support for pdf reports

        # exclude thumbnail and converted images
        self.excludedPatterns.append('png/*png')
        # exclude cropped images
        self.excludedPatterns.append('crop/*crop.tif*')

    def generateHTMLIntro(self):
        """
        Overload the standard HTML introduction.

        This overloaded method allows to implement the specific HTML introduction
        for the Versa microscope.

        It prints the following:
            1. Protocol Title
            2. Customized introduction taken from the YAML file
            3. Sample list

        """
        log.debug('Generating HTML intro for protocol {}'.format(self.protocol))
        self.line('h1', 'VERSA 3D FIB Analysis protocol {}'.format(
            self.protocol), style="text-align:center;", id='intro')
        self.generateCustomHTML('Introduction')
        self.generateHTMLSampleList()


class Sample(HTMLObject):
    """
    The basic class for sample analysis.

    It contains a list of MicroscopePictures

    """

    def __init__(self, full_name):
        # This is the full name, meaning that the whole hierarchy up to the top
        # level is listed.
        #
        # Something like Sample1/SubSample1.2/ThisSubSample
        self.full_name = full_name
        
        # For sake of simplicity
        self.last_name = self.full_name.split('/')[-1]

        # The full_name contains the whole hierarchy, so actually the parent is 
        # already know.
        # 
        # According the full_name, the parent should be
        # '/'.join(self.full_name.split('/')[:-1])
        self.parent = '/'.join(self.full_name.split('/')[:-1])
        if self.parent == '':
            self.parent = None

        # signal dispatcher
        self.signal_dispatcher = SignalDispatcher()

        # a list of subsamples
        # please use full_names!
        self.subsamples = []

        # self.images is a dictionary
        self.images = {}
        log.info('Created a new sample named %s' % (self.full_name))

    def __repr__(self):
        """
        Return the canonical representation of a Sample.

        Returns
        -------
        str
            Canonical representaion of a Sample.

        """
        return f'{self.__class__.__name__}("{self.full_name}")'

    def __str__(self):
        """
        Represent the Sample class.

        Returns
        -------
        msg : string
            The Sample class representation.

        """
        msg = (f'Sample {self.last_name} with parent {self.parent} contains \n'
               f'  + {len(self.subsamples)} subsample(s) \n')
        for ssample in self.subsamples:
            msg += f'    - {ssample}\n'

        msg += f'  + {len(self.images)} image(s)\n'
        for image in self.images:
            msg += f'    - {self.images[image].params["path"]}\n'
        return msg

    def emit_added(self, element_type, element_name, parent_name):
        """
        Cause the signal dispatcher to emit an added_element signal.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being added.
            The following value is implemented:
                - MicroPic: a MicroscopePicture
        element_name : String
            In the case of MicroPic the element_name must be the
            full path of the added element.
        parent_name : String
            In the case of MicroPic, the parent_name is the sample name.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.added_element.emit(
            element_type, element_name, parent_name)

    def emit_removed(self, element_type, element_name, parent_name):
        """
        Cause the signal dispatcher to emit an removed_element signal.

        Parameters
        ----------
        element_type : String
            A constant string identifying the type of element being removed.
            The following value is implemented:
                - MicroPic: a MicroscopePicture
        element_name : String
            In the case of MicroPic the element_name must be the
            full path of the removed element.
        parent_name : String
            In the case of MicroPic, the parent_name is the sample name.

        Returns
        -------
        None.

        """
        self.signal_dispatcher.removed_element.emit(
            element_type, element_name, parent_name)

    def addMicroscopePicture(self, microPic):
        """
        Add a microscope picture to the sample.

        The sample has a dictionary to store all the microscope pictures.
        The picture path is used as a key for the dictionary.

        Parameters
        ----------
        microPic : autoprotocol.MicroscopePicture
            The microscope picture to be added to the sample..

        Returns
        -------
        None.

        """
        self.images[microPic.params['path']] = microPic
        self.emit_added('MicroPic', microPic.params['path'], self.full_name)
        log.info('Adding microscope picture (%s) to %s' % (
            microPic.params['fileName'], self.full_name))
        log.debug('At the moment there are %s pictures in the sample %s' %(
            len(self.images), self.full_name))

    def removeMicroscopePicturePath(self, path):
        """
        Remove a microscope picture using its path.

        Parameters
        ----------
        path : path-lile | string
            The full path of the microscope picture to be removed.

        Returns
        -------
        None.

        """
        try:
            self.removeMicroscopePicture(self.images[path])
        except KeyError:
            log.error(
                'Could not find an image with the following path %s' % str(path))

    def removeMicroscopePicture(self, microPic):
        """
        Remove a microscope picture from the sample.

        Parameters
        ----------
        microPic : autoprotocol.MicroscopePicture
            The microscope picture to be removed to the sample..

        Returns
        -------
        None.

        """
        if microPic.params['path'] in self.images:
            if microPic.getID() in MicroscopePicture._used_ids:
                MicroscopePicture._used_ids.remove(microPic.getID())
            else:
                log.warning('%s was not in the used_ids list.' %
                            microPic.getID())
            log.info('Removed %s from the image list'% (microPic.params['fileName']))
            log.debug('At the moment there are %s pictures in the sample %s' % (len(self.images), self.full_name))
            try:
                os.remove(microPic.params['pngfilename'])
                os.remove(microPic.params['thumbfilename'])
                if microPic.params.get('cropped_path', '') != '':
                    os.remove(microPic.params['cropped_path'])
            except BaseException as e:
                log.warning('Not critical error removing auxiliary files')
                log.exception(e)
            self.emit_removed('MicroPic', microPic.params['path'], self.full_name)
            del(self.images[microPic.params['path']])
        else:
            log.warning('Attempt to remove %s from sample %s, but it was not there' % (microPic.params['fileName'], self.full_name))

    def addSubSample(self, child_sample_name):
        """Add a subsample to the subsample list."""
        if child_sample_name not in self.subsamples:
            self.subsamples.append(child_sample_name)

    def removeSubSample(self, child_sample_name):
        """Remove a subsample from the subsample list."""
        if child_sample_name in self.subsamples:
            self.subsamples.remove(child_sample_name)

    def is_empty(self):
        """
        Check if a Sample is empty.

        A sample is considered empty when it doesn't have any image
        and also no subsamples.

        Returns
        -------
        bool
            True is the sample is empty.

        """
        log.debug('Sample %s has %s subsamples and %s images'
                  % (self.full_name, len(self.subsamples), len(self.images)))
        return (len(self.subsamples) == 0
                and len(self.images) == 0)


class MicroscopePicture(HTMLObject):
    """
    The basic microscope picture class.

    This is actually a pure virtual class that need to be implement for each microscope type

    This basic class has an empty dictionary of parameters

    """

    # a class level list of all used ids
    _used_ids = list()

    # the next custom id to be used
    _next_to_use_id = autoconfig.CUSTOMID_START

    def _reset_ids():
        """
        Reset the used ids list (static method).

        Returns
        -------
        None.

        """
        MicroscopePicture._used_ids = []
        MicroscopePicture._next_to_use_id = autoconfig.CUSTOMID_START

    def __init__(self, path=None, picType=None):
        """
        Construct a microscope picture.

        Parameters
        ----------
        path : str | path-like opject, optional
            The path to the image.

        picType : str, optional
            It corresponds to the type of image / microscope

        Returns
        -------
        None.

        """
        # initialize all the parameters dictionary
        self.params = dict()
        # TODO: replace all those paths with path-objects.
        self.params['path'] = path
        self.params['picType'] = picType
        self.params['fileName'] = os.path.split(path)[-1]
        self.params['fileExt'] = os.path.splitext(os.path.split(path)[-1])[1]
        self.params['id'] = ''
        log.info('Created a new MicroscopePicture (%s)' %
                 self.params['fileName'])
        self.params['thumbfile'] = self.generatePNG(
             autoconfig.IMAGE_SAMPLE_THUMB_MAX_WIDTH, 'thumb-png', forceRegen=False)
        self.params['pngfile'] = self.generatePNG(0, 'png', forceRegen=False)

    def __repr__(self):
        """
        Return the representation of a MicroscopePicture.

        Returns
        -------
        msg, str
            The representation of a MicroscopePicture.

        """
        return f'{self.__class__.__name__}(path=\"{self.params["path"]}\",picType={self.params["picType"]})'

    def __str__(self):
        """
        Print out the most relevant info of a MicroscopePicture.

        Returns
        -------
        msg : str
            The representation of a MicroscopePicture.

        """
        msg = 'Microscope Image with the following parameters\n'
        for key in self.params:
            msg += f'  - {key}: {self.params[key]}\n'
        return msg

    def _is_ID_taken(picId):
        """
        Check if a ID has been used already.

        Parameters
        ----------
        id : int
            Identification number to be checked.

        Returns
        -------
        bool
            Return True if it is already used or
            False if the ID is good to be used.

        """
        if picId in MicroscopePicture._used_ids:
            return True
        return False

    def _get_id(self, pattern, tifftagcode=None):
        """
        Get a valid and unique MicroscopePicture ID.

        This method is retrieving a unique MicroscopePicture ID for the newly
        added image.

        It is getting an ID from the filename using a regular expression with
        the provided pattern and compare it with the ID stored in the TIFF file
        with the TIFF tag pointed by tifftagcode.

        Four different scenarios can happen:
            1. No valid ID is available in neither the filename nor in the TIFF
               tag. Then a valid one is internally generated and saved in the
               TIFF Tag for further use
            2. The ID from the filename is valid while the one from the TIFF tag
               is either empty or invalid. The one from the filename is accepted
               and saved to the TIFF tag for further use.
            3. The ID from the TIFF tag is good, but not the one from the
               filename. Just keep on using the one from TIFF tag.
            4. Both IDs are good. Then we take the one from the TIFF tag.

        Parameters
        ----------
        pattern : string
            Regular expression patter to identify the ID.
            See _get_id_from_filename for more details.
        tifftagcode : int, optional
            The code of the TIFF tag where the ID is located.
            If none, then the default value stored in autoconfig.CUSTOMID_TIFFCODE
            is used. The default is None.

        Returns
        -------
        None.

        """
        filename_id = self._get_id_from_filename(pattern)
        tifftag_id = self._get_id_from_tifftag(tifftagcode)
        need_file_flashing = False

        # Case 1
        if filename_id is None and tifftag_id is None:
            # it was not possible to get the ID neither from the filename
            # nor from the tifftag.
            # we need a fresh unique one

            good_id = self._get_unique_ID()
            need_file_flashing = True

        # Case 2
        if filename_id is not None and tifftag_id is None:
            # we got an id from the filename but none from the tifftag.
            # for the sake of clarity write it to the file

            good_id = filename_id
            need_file_flashing = True

        # Case 3
        if filename_id is None and tifftag_id is not None:
            # we got an id from the tifftag, but none from the filename
            # we can only take the one from the tifftag
            good_id = tifftag_id

        # Case 4
        if filename_id is not None and tifftag_id is not None:
            # we got id from both sources.
            # we will ignore the filename_id and consider the tifftag_id
            # valid
            good_id = tifftag_id

        self.params['id'] = good_id
        MicroscopePicture._used_ids.append(good_id)
        if need_file_flashing:
            self._write_id_in_file(id=good_id, tifftagcode=tifftagcode)

    def _get_id_from_filename(self, pattern):
        r"""
        Try to get the ID from the filename using regular expression.

        This method must be always called by _get_id and will try to get a valid
        ID from the filename. To do so, it uses a regular expression pattern with
        a group named ID.

        For example this is a valid pattern: '^(?P<ID>[0-9]+)[\\w\\W]*$'.

        If a valid unique ID is found, it is returned for further use.
        None is returned if the pattern matching could not find any ID or
        if the matched ID is already in use.

        Parameters
        ----------
        pattern : str
            Regular expression pattern with a group named ID.
            An example is '^(?P<ID>[0-9]+)[\\w\\W]*$'

        Returns
        -------
        int or None
            The ID retrieved from the filename.
            If no ID is found or if it is already in use, None is returned

        """
        match = re.search(pattern, self.params['fileName'])
        if match:
            if MicroscopePicture._is_ID_taken(int(match.group('ID'))):
                log.debug('ID %s taken from filename but already in use' %
                          match.group('ID'))
                return None
            else:
                return int(match.group('ID'))

    def _get_id_from_tifftag(self, tifftagcode=None):
        """
        Try to get the ID from the TIFF tag in the file.

        This method will try to get the picture ID from a TIFF tag stored in
        the TIFF file at position tifftagcode.

        If there is an ID at the indicated position and this is unique, then
        it is returned. Otherwise None is returned.

        Parameters
        ----------
        tifftagcode : int, optional
            The code of the TIFF Tag where the ID is stored.
            If None, then the system level constant autoconfig.CUSTOMID_TIFFCODE
            is used.
            The default is None.

        Returns
        -------
        int or None
            The ID retrieved from the TIFF Tag.
            If no ID is found or if it is already in use, None is returned

        """
        if tifftagcode is None:
            tifftagcode = autoconfig.CUSTOMID_TIFFCODE
        with Image.open(self.getParameter('path')) as img:
            tiffinfo = img.tag_v2
            if tifftagcode in tiffinfo:
                try:
                    if MicroscopePicture._is_ID_taken(int(tiffinfo[tifftagcode])):
                        log.warning('ID %s taken from TIFF tag already in use.'
                                     % int(tiffinfo[tifftagcode]))
                        log.warning('Removing TIFF tag from MicroscopePicture %s because of conflicts'
                                    % self.params['fileName'])
                        self._write_id_in_file(reset=True)
                        log.warning(
                            'Possible wrong assignements of HTML customization in the protocol')
                        return None
                    else:
                        return int(tiffinfo[tifftagcode])
                except ValueError:
                    log.warning(
                        'The content of the TIFF tag cannot be converted in a valid ID.')
                    log.warning('Resetting the TIFF tag')
                    self._write_id_in_file(reset=True)
                    return None
            else:
                return None

    def _get_unique_ID(self):
        """
        Obtain an internally generated unique ID.

        This is the last chance for the ID generation. If all other attempts
        are failing, then an internally generated ID is assigned.

        Returns
        -------
        Int
            A valid ID for the MicroscopePicture

        """
        while MicroscopePicture._is_ID_taken(
                MicroscopePicture._next_to_use_id
        ):
            MicroscopePicture._next_to_use_id += 1
        return MicroscopePicture._next_to_use_id

    def _write_id_in_file(self, id=None, tifftagcode=None, reset=False):
        """
        Write/Update/Reset the ID in the TIFF Tag code with picture ID.

        This is the swiss army knife of the TIFF Tag picture ID.
        Using the PIL package it is opening the TIFF file, retrieving the
        tiffinfo dictionary with all the tags and writing/updating or
        resetting its value.
        The modified tiffinfo is saved to the original file.

        Parameters
        ----------
        id : int, optional
            The id to be written to the TIFF file.
            If it is None, then the id stored in the MicroscopePicture is used.
            The default is None.
        tifftagcode : int, optional
            The code of the TIFF tag where the id has to be written.
            If None, then the system default autoconfig.CUSTOMID_TIFFCODE is used.
            The default is None.
        reset : bool, optional
            A boolean control to force the reset of the TIFF Tag.
            When True, instead of writing the id, an empty string is stored into
            the file.
            The default is False.

        Raises
        ------
        OSError
            Raised if the MicroscopePicture has no path defined. In this way
            the TIFF file cannot be opened.
        AttributeError
            Raised if id is None and the id in the MicroscopePicture paramater
            dictionary is not set.

        Returns
        -------
        None.

        """
        if self.params['path'] is None:
            raise OSError('Picture path not provided')

        if reset:
            write_id = ''
        else:
            if id is None:
                if self.params['id'] is None:
                    raise AttributeError(
                        'Something went wrong with picture ID assigment')
                else:
                    write_id = self.params['id']
            else:
                write_id = id

        if tifftagcode is None:
            tifftagcode = autoconfig.CUSTOMID_TIFFCODE

        if isinstance(self.params['path'], Path):
            img_path = self.params['path']
        else:
            img_path = Path(self.params['path'])

        with Image.open(img_path) as img:
            tiffinfo = img.tag_v2
            # this tag should not be existing, but check just in case
            if tifftagcode in tiffinfo:
                # this is unexpected
                # inform the user that the tag will be overwritten and lost
                log.warning('Microscope picture %s has already ID tag (%s).'
                            % (self.params['fileName'], tiffinfo[tifftagcode]))
                log.warning('It will be overwritten!')

            # add or modify with the id number
            tiffinfo[tifftagcode] = str(write_id)
            img.save(img_path, tiffinfo=tiffinfo)
        log.debug('ID stored in the TIFF tag for further use')

    def getID(self):
        """
        Return the ID of the Microscope Picture.

        Returns
        -------
        ID
            The microscope picture ID.

        """
        return self.params['id']

    def getPicType(self):
        """
        Return the picture type.

        Returns
        -------
        picType : str
            The type of picture.

        """
        return self.params['picType']

    def getParameters(self):
        """
        Return the picture parameter dictionary.

        Returns
        -------
        The whole parameter dictionary

        """
        return self.params

    def getParameter(self, parName):
        """
        Return a specific parameter from the dictionary if it exists, None if it is not existing.

        Parameters
        ----------
        parName : String
            Parameter Name.

        Returns
        -------
        The value of the parameter or None if is not existing

        """
        try:
            return self.params[parName]
        except BaseException:
            return None

    def generatePNG(self, maxWidth=400, subfolder='png-thumb', forceRegen=False):
        """
        Generate a PNG version of a Microscope Picture.

        Parameters
        ----------
        maxWidth : integer, optional
            The horizontal size of the png image.
            Set to 0 to disable the scaling.
            The default is 400.
        subfolder : string, optional
            A relative directory to the sample where the generated PNG should be stored.
            The default is 'png-thumb'.
        forceRegen : bool, optional
            Force the regenaration of a PNG image even if it exists already.
            The default is False.

        Returns
        -------
        thumbfile : string
            The URI of the generated PNG file.

        """
        # save the file in a subfolder defined by subfolder
        # make the folder if it doesn't exist
        thumbpath = os.path.join(os.path.split(
            self.params['path'])[0], subfolder)
        if not os.path.exists(thumbpath):
            os.mkdir(thumbpath)
        thumbfilename = os.path.splitext(os.path.split(
            self.params['path'])[-1])[0] + '-{}.png'.format(subfolder)
        thumbfile = os.path.join(thumbpath, thumbfilename)

        if maxWidth == 0:
            self.params['pngfilename'] = thumbfile
            self.params['pngurl'] = self.convertPath2URI(thumbfile)
        else:
            self.params['thumbfilename'] = thumbfile
            self.params['thumburl'] = self.convertPath2URI(thumbfile)

        if not forceRegen and exists(thumbfile):
            log.debug('Skipping the generation of PNG for {} because already existing'.format(
                self.params['fileName']))

        else:
            if maxWidth == 0:
                log.debug('Converting image {} in PNG format'.format(
                    self.params['fileName']))
            else:
                log.debug('Generating thumbnail of {} with maxWidth {}'.format(
                    self.params['fileName'], maxWidth))
            with Image.open(self.params['path'], 'r') as image:
                w, h = image.size
                log.debug('Image size {} x {}'.format(w, h))
                if maxWidth > 0:
                    image.thumbnail((round(maxWidth), round(maxWidth * h / w)))
                image.convert('RGB')
                image.save(thumbfile, format='PNG')

        thumbfile = self.convertPath2URI(thumbfile)
        thumbfile = thumbfile.replace('\\', '/')

        return thumbfile


class FEIPicture(MicroscopePicture):
    """
    The basic FEI pictures.

    All relevant parameters for the logbook are taken from the TIFFfile and
    inserted in the parameter dictionary.

    """

    def __init__(self, path=None):
        MicroscopePicture.__init__(self, path)
        self.getTIFFFileTags()
        if autoconfig.FEI_AUTO_CALIBRATION:
            self.calibrate()
        if autoconfig.FEI_DATABAR_REMOVAL:
            self.crop_databar()

    def calibrate(self):
        """
        Calibrate the FEI image.

        Resolution information stored in standard TIFF tags of FEI images are
        wrong. In order to have a direct calibration of the image while being
        open with ImageJ for example, the information provided in the FEI
        specific tag must be used.

        This method getting the picture resolution from the standard tags and
        comparing it with the one obtained with the FEI tags. If the two are
        different, then it means that this image was never calibrated before.
        Calibration information from FEI tags are moved to the standard tags.
        The picture file is updated and saved.

        If the two sets of resolution are the same, then there is no need to
        perform any calibration.

        Returns
        -------
        None.

        """
        log.debug('Calibrating %s' % self.params['fileName'])
        with Image.open(self.params['path']) as tif:

            tiff_tags = tif.tag_v2
            tif_res = autotools.getPictureResolution(
                tiff_tags, 'tif', autotools.Resolution_Unit.cm)
            fei_res = autotools.getPictureResolution(
                tiff_tags, 'fei', autotools.Resolution_Unit.cm)
            if tif_res == fei_res:
                pass
            else:
                xres, yres, ures = fei_res.as_tuple()
                tif.save(self.params['path'], resolution_unit=ures, x_resolution=xres, y_resolution=yres,
                         tiffinfo=tiff_tags)

    def crop_databar(self, forceRegen=False):
        """
        Remove the databar from a FEI picture.

        FEI microscopes are saving a databar on the bottom part of the image
        contaning user selected information.

        While this databar is generally very useful, it is not nice to see when
        the image is published on a scientific journal.

        This method allows to remove the databar saving the cropped image in
        a separated file in order to keep also the original.

        The cropped file is saved in the picture parameter:
            params['cropped_path'] with the full path including the filename
            params['cropped_url'] URL of the cropped image as it appears on the
                image server.

        Parameters
        ----------
        forceRegen : bool, optional
            Force the regenaration of the cropped image even if it exists already.
            The default is False.

        Returns
        -------
        None.

        """
        # Check if the cropped file already exists.
        orig_path = Path(self.params['path'])
        crop_img_path = orig_path.parent / \
            Path('crop') / Path(str(orig_path.stem)
                                + '_crop' + str(orig_path.suffix))
        if not forceRegen and crop_img_path.exists(): 
            log.debug('Skipping generation of cropped image because it already exists')
            return
        
        log.debug('Generating a copy of %s with cropped databar' % self.params['fileName'])
        with Image.open(self.params['path']) as full_img:
            tiffinfo = full_img.tag_v2
            image_xsize, image_ysize = full_img.size

            fei_tag_code = 34682
            fei_metadata = configparser.ConfigParser(allow_no_value=True)
            fei_metadata.read_string(tiffinfo[fei_tag_code])

            scan_width = fei_metadata.getint('Image', 'ResolutionX')
            scan_height = fei_metadata.getint('Image', 'ResolutionY')

            if (image_xsize, image_ysize) != (scan_width, scan_height):
                crop_img = full_img.crop((0, 0, scan_width, scan_height))
                xside_code = 256
                yside_code = 257
                tiffinfo[xside_code] = scan_width
                tiffinfo[yside_code] = scan_height

                self.params['cropped_path'] = crop_img_path
                self.params['cropped_url'] = self.convertPath2URI(
                    crop_img_path)
                if not crop_img_path.parent.exists():
                    crop_img_path.parent.mkdir(parents=True, exist_ok=True)
                crop_img.save(crop_img_path, tiffinfo=tiffinfo)

    def getTIFFFileTags(self):
        """
        Get the TIFF file tags.

        Open the tifffile corresponding to the FEI picture using the tifffile
        library and get the fei_metadata dictionary.

        Relevant information for the logbook are transferred from the fei_metadata
        to the internal dictionary.

        The magnification is calculated starting from the display width and the
        horizontal field of view.

        Raises
        ------
        TypeError
            If the TIFF file is not a FEI image.

        Returns
        -------
        None.

        """
        path = self.params['path']

        with Image.open(path) as tif:

            tiff_tags = tif.tag_v2
            fei_tag_code = 34682

            if fei_tag_code not in tiff_tags:
                raise autoerror.NotFEIMicroscopePicture(
                    'Picture %s is not FEI' % path
                )

            fei_metadata = configparser.ConfigParser(allow_no_value=True)
            fei_metadata.read_string(tiff_tags[fei_tag_code])

            # for HV add kV if > 1000
            self.params['hv'] = (
                fei_metadata.get('Beam', 'HV') + 'V',
                str(round(fei_metadata.getfloat('Beam', 'HV') / 1000)) + 'kV'
            )[fei_metadata.getfloat('Beam', 'HV') > 1000]

            self.params['beam'] = fei_metadata.get('Beam', 'Beam')
            self.params['hfw'] = fei_metadata.getfloat(
                self.params['beam'], 'HFW')
            self.params['dispwidth'] = fei_metadata.getfloat(
                'System', 'DisplayWidth')
            # for magnification there is a mystery 1.25 scale factor
            # add kx if > 1000
            self.params['magnification'] = (
                str(round(self.params['dispwidth']
                    / self.params['hfw'] / 1.25)) + 'x',
                str(round(self.params['dispwidth']
                    / self.params['hfw'] / 1.25 / 1000)) + 'kx'
            )[round(self.params['dispwidth'] / self.params['hfw'] / 1.25) > 1000]
            self.params['spotsize'] = fei_metadata.getfloat('Beam', 'Spot')
            self.params['detector'] = f"{fei_metadata.get('Detectors','Mode')}.{fei_metadata.get('Detectors','Name')}"
            self.params['vacuum'] = fei_metadata.get('Vacuum', 'UserMode')
            self.params['userText'] = fei_metadata.get('User', 'UserText')
            self.params['width'] = fei_metadata.getfloat(
                'Image', 'ResolutionX')
            self.params['height'] = fei_metadata.getfloat(
                'Image', 'ResolutionY')
            self.params['resolution'] = (fei_metadata.getfloat('Image', 'ResolutionX'),
                                         fei_metadata.getfloat('Image', 'ResolutionY'))
            self.params['resolutionPrint'] = f"({fei_metadata['Image']['ResolutionX']} x {fei_metadata['Image']['ResolutionY']})"
        for key in self.params:
            log.debug('{}  --> {}'.format(key, self.params[key]))

    def generateHTMLCode(self, yamlDict):
        """
        Generate the HTML code corresponding to the FEI image .

        Parameters
        ----------
        yamlDict : dictionary
            A dictionary containing the customized fields.

        Returns
        -------
        None.

        """
        log.debug('Generating HTML of picture {}'.format(
            self.getParameter('FileName')))

        with self.tag('tr'):
            with self.tag('td', colspan=5, style='text-align:center;height:50px;background-color:cyan'):
                self.line('b', self.params['path'])
            with self.tag('td', style='text-align:center;height:50px;background-color:cyan'):
                self.line('a', 'PNG', href=self.params['pngurl'])
            with self.tag('td', style='text-align:center;height:50px;background-color:cyan'):
                if autoconfig.FEI_DATABAR_REMOVAL and self.params.get('cropped_url'):
                    # TODO: check if the self.convertPath2URI() can be used here
                    with self.tag('a', href=self.params['path'].replace(str(
                            autoconfig.IMAGE_SERVER_BASE_PATH), autoconfig.IMAGE_SERVER_ROOT_URL).replace('\\', '/')):
                        self.text('TIFF (full)')
                    self.text(' / ')
                    with self.tag('a', href=self.params['cropped_url']):
                        self.text('TIFF (no databar)')
                else:
                    # TODO: check if the self.convertPath2URI() can be used here
                    self.line('a', 'TIFF', href=self.params['path'].replace(str(
                        autoconfig.IMAGE_SERVER_BASE_PATH), autoconfig.IMAGE_SERVER_ROOT_URL).replace('\\', '/'))
        with self.tag('tr'):
            with self.tag('th', colspan=2, rowspan=2):
                with self.tag('figure', klass='image'):
                    with self.tag('a', href=self.params['pngurl']):
                        self.doc.stag('img', width=autoconfig.IMAGE_SAMPLE_THUMB_MAX_WIDTH - 10,
                                      alt=os.path.split(self.params['pngurl'])[-1], src=self.params['thumburl'])
                    caption = os.path.split(self.params['path'])[-1]
                    if 'Caption' in yamlDict and yamlDict['Caption']:
                        caption = yamlDict['Caption']
                    self.line('figcaption', caption)
            with self.tag('td'):
                self.line('strong', 'ID: ')
                self.text(self.params['id'])
            with self.tag('td'):
                self.line('strong', 'HV: ')
                self.text(self.params['hv'])
            with self.tag('td'):
                self.line('strong', 'Beam: ')
                self.text(self.params['beam'])
            with self.tag('td'):
                self.line('strong', 'Magnification: ')
                self.text(self.params['magnification'])
            with self.tag('td'):
                self.line('strong', 'Resolution: ')
                self.text(self.params['resolutionPrint'])
        with self.tag('tr'):
            with self.tag('td'):
                self.line('strong', 'Spot size: ')
                self.text(self.params['spotsize'])
            with self.tag('td'):
                self.line('strong', 'Detector: ')
                self.text(self.params['detector'])
            with self.tag('td'):
                self.line('strong', 'Vacuum: ')
                self.text(self.params['vacuum'])
            with self.tag('td'):
                self.line('strong', 'User text: ')
                self.text(self.params['userText'])
            with self.tag('td'):
                self.line('strong', 'Filename: ')
                self.text(os.path.split(self.params['path'])[-1])

        subkey = 'Description'
        exkey = 'Extra'
        if subkey in yamlDict:
            with self.tag('tr'):
                with self.tag('td', colspan=7):
                    self.doc.asis(markdown.markdown(yamlDict[subkey]))
        if exkey in yamlDict:
            if len(yamlDict[exkey]) > 0:
                with self.tag('tr'):
                    with self.tag('td', colspan=7):
                        self.line('h3', 'Additional information')
                        self.line('p', yamlDict[exkey])


class QuattroFEIPicture(FEIPicture):
    """
    Quattro Pictures, a subclass of FEI.

    Quattro images should be named according to this convention:

        id-samplename-someproperties.tif

    The name file is parsed against a regular expression and the picture id is stored
    in the parameters dictionary.

    """

    filename_pattern = '^(?P<ID>[0-9]+)[\\w\\W]*$'

    def __init__(self, path=None):
        FEIPicture.__init__(self, path)
        self.params['picType'] = 'FEI.Quattro'
        self._get_id(QuattroFEIPicture.filename_pattern)


class VersaFEIPicture(FEIPicture):
    """
    Versa Pictures, a subclass of FEI.

    Quattro images should be named according to this convention:

        samplename-someproperties_id.tif

    The name file is parsed against a regular expression and the picture id is stored
    in the parameters dictionary.

    """

    # (?P<name>...)
    # sometext-000.tif
    # sometext_000.tif
    filename_pattern = '^[\\w\\W]*[-_](?P<ID>[0-9]+).[\\w\\W]*$'

    def __init__(self, path=None):
        FEIPicture.__init__(self, path)
        self.params['picType'] = 'FEI.Versa'
        self._get_id(VersaFEIPicture.filename_pattern)
