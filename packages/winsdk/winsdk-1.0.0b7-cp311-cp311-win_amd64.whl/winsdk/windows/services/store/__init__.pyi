# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.7

import enum
import datetime
import sys
import types
import typing

import winsdk._winrt as _winrt
import winsdk.windows.applicationmodel
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.system
import winsdk.windows.web.http

class StoreCanLicenseStatus(enum.IntEnum):
    NOT_LICENSABLE_TO_USER = 0
    LICENSABLE = 1
    LICENSE_ACTION_NOT_APPLICABLE_TO_PRODUCT = 2
    NETWORK_ERROR = 3
    SERVER_ERROR = 4

class StoreConsumableStatus(enum.IntEnum):
    SUCCEEDED = 0
    INSUFFICENT_QUANTITY = 1
    NETWORK_ERROR = 2
    SERVER_ERROR = 3

class StoreDurationUnit(enum.IntEnum):
    MINUTE = 0
    HOUR = 1
    DAY = 2
    WEEK = 3
    MONTH = 4
    YEAR = 5

class StorePackageUpdateState(enum.IntEnum):
    PENDING = 0
    DOWNLOADING = 1
    DEPLOYING = 2
    COMPLETED = 3
    CANCELED = 4
    OTHER_ERROR = 5
    ERROR_LOW_BATTERY = 6
    ERROR_WI_FI_RECOMMENDED = 7
    ERROR_WI_FI_REQUIRED = 8

class StorePurchaseStatus(enum.IntEnum):
    SUCCEEDED = 0
    ALREADY_PURCHASED = 1
    NOT_PURCHASED = 2
    NETWORK_ERROR = 3
    SERVER_ERROR = 4

class StoreQueueItemExtendedState(enum.IntEnum):
    ACTIVE_PENDING = 0
    ACTIVE_STARTING = 1
    ACTIVE_ACQUIRING_LICENSE = 2
    ACTIVE_DOWNLOADING = 3
    ACTIVE_RESTORING_DATA = 4
    ACTIVE_INSTALLING = 5
    COMPLETED = 6
    CANCELED = 7
    PAUSED = 8
    ERROR = 9
    PAUSED_PACKAGES_IN_USE = 10
    PAUSED_LOW_BATTERY = 11
    PAUSED_WI_FI_RECOMMENDED = 12
    PAUSED_WI_FI_REQUIRED = 13
    PAUSED_READY_TO_INSTALL = 14

class StoreQueueItemKind(enum.IntEnum):
    INSTALL = 0
    UPDATE = 1
    REPAIR = 2

class StoreQueueItemState(enum.IntEnum):
    ACTIVE = 0
    COMPLETED = 1
    CANCELED = 2
    ERROR = 3
    PAUSED = 4

class StoreRateAndReviewStatus(enum.IntEnum):
    SUCCEEDED = 0
    CANCELED_BY_USER = 1
    NETWORK_ERROR = 2
    ERROR = 3

class StoreUninstallStorePackageStatus(enum.IntEnum):
    SUCCEEDED = 0
    CANCELED_BY_USER = 1
    NETWORK_ERROR = 2
    UNINSTALL_NOT_APPLICABLE = 3
    ERROR = 4

Self = typing.TypeVar('Self')

class StorePackageUpdateStatus:
    package_family_name: str
    package_download_size_in_bytes: _winrt.UInt64
    package_bytes_downloaded: _winrt.UInt64
    package_download_progress: _winrt.Double
    total_download_progress: _winrt.Double
    package_update_state: StorePackageUpdateState
    def __new__(cls: typing.Type[StorePackageUpdateStatus], package_family_name: str, package_download_size_in_bytes: _winrt.UInt64, package_bytes_downloaded: _winrt.UInt64, package_download_progress: _winrt.Double, total_download_progress: _winrt.Double, package_update_state: StorePackageUpdateState) -> StorePackageUpdateStatus: ...

class StoreAcquireLicenseResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    store_package_license: typing.Optional[StorePackageLicense]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreAcquireLicenseResult: ...

class StoreAppLicense(_winrt.Object):
    add_on_licenses: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, StoreLicense]]
    expiration_date: datetime.datetime
    extended_json_data: str
    is_active: _winrt.Boolean
    is_trial: _winrt.Boolean
    is_trial_owned_by_this_user: _winrt.Boolean
    sku_store_id: str
    trial_time_remaining: datetime.timedelta
    trial_unique_id: str
    is_disc_license: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreAppLicense: ...

class StoreAvailability(_winrt.Object):
    end_date: datetime.datetime
    extended_json_data: str
    price: typing.Optional[StorePrice]
    store_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreAvailability: ...
    @typing.overload
    def request_purchase_async(self) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: typing.Optional[StorePurchaseProperties]) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreCanAcquireLicenseResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    licensable_sku: str
    status: StoreCanLicenseStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreCanAcquireLicenseResult: ...

class StoreCollectionData(_winrt.Object):
    acquired_date: datetime.datetime
    campaign_id: str
    developer_offer_id: str
    end_date: datetime.datetime
    extended_json_data: str
    is_trial: _winrt.Boolean
    start_date: datetime.datetime
    trial_time_remaining: datetime.timedelta
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreCollectionData: ...

class StoreConsumableResult(_winrt.Object):
    balance_remaining: _winrt.UInt32
    extended_error: winsdk.windows.foundation.HResult
    status: StoreConsumableStatus
    tracking_id: _winrt.Guid
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreConsumableResult: ...

class StoreContext(_winrt.Object):
    user: typing.Optional[winsdk.windows.system.User]
    can_silently_download_store_package_updates: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreContext: ...
    def acquire_store_license_for_optional_package_async(self, optional_package: typing.Optional[winsdk.windows.applicationmodel.Package]) -> winsdk.windows.foundation.IAsyncOperation[StoreAcquireLicenseResult]: ...
    def can_acquire_store_license_async(self, product_store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]: ...
    def can_acquire_store_license_for_optional_package_async(self, optional_package: typing.Optional[winsdk.windows.applicationmodel.Package]) -> winsdk.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]: ...
    def download_and_install_store_packages_async(self, store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def find_store_product_for_package_async(self, product_kinds: typing.Iterable[str], package: typing.Optional[winsdk.windows.applicationmodel.Package]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductResult]: ...
    def get_app_and_optional_store_package_updates_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StorePackageUpdate]]: ...
    def get_app_license_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreAppLicense]: ...
    def get_associated_store_products_async(self, product_kinds: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_associated_store_products_with_paging_async(self, product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...
    def get_associated_store_queue_items_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    def get_consumable_balance_remaining_async(self, product_store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreConsumableResult]: ...
    def get_customer_collections_id_async(self, service_ticket: str, publisher_user_id: str) -> winsdk.windows.foundation.IAsyncOperation[str]: ...
    def get_customer_purchase_id_async(self, service_ticket: str, publisher_user_id: str) -> winsdk.windows.foundation.IAsyncOperation[str]: ...
    @staticmethod
    def get_default() -> typing.Optional[StoreContext]: ...
    @staticmethod
    def get_for_user(user: typing.Optional[winsdk.windows.system.User]) -> typing.Optional[StoreContext]: ...
    def get_store_product_for_current_app_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreProductResult]: ...
    @typing.overload
    def get_store_products_async(self, product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    @typing.overload
    def get_store_products_async(self, product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str], store_product_options: typing.Optional[StoreProductOptions]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_store_queue_items_async(self, store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    def get_user_collection_async(self, product_kinds: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[StoreProductQueryResult]: ...
    def get_user_collection_with_paging_async(self, product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...
    def report_consumable_fulfillment_async(self, product_store_id: str, quantity: _winrt.UInt32, tracking_id: _winrt.Guid) -> winsdk.windows.foundation.IAsyncOperation[StoreConsumableResult]: ...
    def request_download_and_install_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_and_install_store_packages_async(self, store_ids: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_download_and_install_store_packages_async(self, store_ids: typing.Iterable[str], store_package_install_options: typing.Optional[StorePackageInstallOptions]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def request_download_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    @typing.overload
    def request_purchase_async(self, store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_id: str, store_purchase_properties: typing.Optional[StorePurchaseProperties]) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    def request_rate_and_review_app_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreRateAndReviewResult]: ...
    def request_uninstall_store_package_async(self, package: typing.Optional[winsdk.windows.applicationmodel.Package]) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def request_uninstall_store_package_by_store_id_async(self, store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def set_install_order_for_associated_store_queue_items_async(self, items: typing.Iterable[StoreQueueItem]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]: ...
    def try_silent_download_and_install_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def try_silent_download_store_package_updates_async(self, store_package_updates: typing.Iterable[StorePackageUpdate]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]: ...
    def uninstall_store_package_async(self, package: typing.Optional[winsdk.windows.applicationmodel.Package]) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def uninstall_store_package_by_store_id_async(self, store_id: str) -> winsdk.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]: ...
    def add_offline_licenses_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[StoreContext, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_offline_licenses_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StoreImage(_winrt.Object):
    caption: str
    height: _winrt.UInt32
    image_purpose_tag: str
    uri: typing.Optional[winsdk.windows.foundation.Uri]
    width: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreImage: ...

class StoreLicense(_winrt.Object):
    expiration_date: datetime.datetime
    extended_json_data: str
    in_app_offer_token: str
    is_active: _winrt.Boolean
    sku_store_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreLicense: ...

class StorePackageInstallOptions(_winrt.Object):
    allow_forced_app_restart: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageInstallOptions: ...
    def __new__(cls: typing.Type[StorePackageInstallOptions]) -> StorePackageInstallOptions:...

class StorePackageLicense(_winrt.Object):
    is_valid: _winrt.Boolean
    package: typing.Optional[winsdk.windows.applicationmodel.Package]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageLicense: ...
    def close(self) -> None: ...
    def release_license(self) -> None: ...
    def add_license_lost(self, handler: winsdk.windows.foundation.TypedEventHandler[StorePackageLicense, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_license_lost(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StorePackageUpdate(_winrt.Object):
    mandatory: _winrt.Boolean
    package: typing.Optional[winsdk.windows.applicationmodel.Package]
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageUpdate: ...

class StorePackageUpdateResult(_winrt.Object):
    overall_state: StorePackageUpdateState
    store_package_update_statuses: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StorePackageUpdateStatus]]
    store_queue_items: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreQueueItem]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePackageUpdateResult: ...

class StorePrice(_winrt.Object):
    currency_code: str
    formatted_base_price: str
    formatted_price: str
    formatted_recurrence_price: str
    is_on_sale: _winrt.Boolean
    sale_end_date: datetime.datetime
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePrice: ...

class StoreProduct(_winrt.Object):
    description: str
    extended_json_data: str
    has_digital_download: _winrt.Boolean
    images: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreImage]]
    in_app_offer_token: str
    is_in_user_collection: _winrt.Boolean
    keywords: typing.Optional[winsdk.windows.foundation.collections.IVectorView[str]]
    language: str
    link_uri: typing.Optional[winsdk.windows.foundation.Uri]
    price: typing.Optional[StorePrice]
    product_kind: str
    skus: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreSku]]
    store_id: str
    title: str
    videos: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreVideo]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProduct: ...
    def get_is_any_sku_installed_async(self) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...
    @typing.overload
    def request_purchase_async(self) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: typing.Optional[StorePurchaseProperties]) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreProductOptions(_winrt.Object):
    action_filters: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductOptions: ...
    def __new__(cls: typing.Type[StoreProductOptions]) -> StoreProductOptions:...

class StoreProductPagedQueryResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    has_more_results: _winrt.Boolean
    products: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, StoreProduct]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductPagedQueryResult: ...
    def get_next_async(self) -> winsdk.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]: ...

class StoreProductQueryResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    products: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, StoreProduct]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductQueryResult: ...

class StoreProductResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    product: typing.Optional[StoreProduct]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreProductResult: ...

class StorePurchaseProperties(_winrt.Object):
    name: str
    extended_json_data: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePurchaseProperties: ...
    @typing.overload
    def __new__(cls: typing.Type[StorePurchaseProperties], name: str) -> StorePurchaseProperties:...
    @typing.overload
    def __new__(cls: typing.Type[StorePurchaseProperties]) -> StorePurchaseProperties:...

class StorePurchaseResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: StorePurchaseStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StorePurchaseResult: ...

class StoreQueueItem(_winrt.Object):
    install_kind: StoreQueueItemKind
    package_family_name: str
    product_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreQueueItem: ...
    def cancel_install_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def get_current_status(self) -> typing.Optional[StoreQueueItemStatus]: ...
    def pause_install_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def resume_install_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def add_completed(self, handler: winsdk.windows.foundation.TypedEventHandler[StoreQueueItem, StoreQueueItemCompletedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_status_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[StoreQueueItem, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_status_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StoreQueueItemCompletedEventArgs(_winrt.Object):
    status: typing.Optional[StoreQueueItemStatus]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreQueueItemCompletedEventArgs: ...

class StoreQueueItemStatus(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    package_install_extended_state: StoreQueueItemExtendedState
    package_install_state: StoreQueueItemState
    update_status: StorePackageUpdateStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreQueueItemStatus: ...

class StoreRateAndReviewResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    extended_json_data: str
    status: StoreRateAndReviewStatus
    was_updated: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreRateAndReviewResult: ...

class StoreRequestHelper(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreRequestHelper: ...
    @staticmethod
    def send_request_async(context: typing.Optional[StoreContext], request_kind: _winrt.UInt32, parameters_as_json: str) -> winsdk.windows.foundation.IAsyncOperation[StoreSendRequestResult]: ...

class StoreSendRequestResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    response: str
    http_status_code: winsdk.windows.web.http.HttpStatusCode
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreSendRequestResult: ...

class StoreSku(_winrt.Object):
    availabilities: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreAvailability]]
    bundled_skus: typing.Optional[winsdk.windows.foundation.collections.IVectorView[str]]
    collection_data: typing.Optional[StoreCollectionData]
    custom_developer_data: str
    description: str
    extended_json_data: str
    images: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreImage]]
    is_in_user_collection: _winrt.Boolean
    is_subscription: _winrt.Boolean
    is_trial: _winrt.Boolean
    language: str
    price: typing.Optional[StorePrice]
    store_id: str
    subscription_info: typing.Optional[StoreSubscriptionInfo]
    title: str
    videos: typing.Optional[winsdk.windows.foundation.collections.IVectorView[StoreVideo]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreSku: ...
    def get_is_installed_async(self) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...
    @typing.overload
    def request_purchase_async(self) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...
    @typing.overload
    def request_purchase_async(self, store_purchase_properties: typing.Optional[StorePurchaseProperties]) -> winsdk.windows.foundation.IAsyncOperation[StorePurchaseResult]: ...

class StoreSubscriptionInfo(_winrt.Object):
    billing_period: _winrt.UInt32
    billing_period_unit: StoreDurationUnit
    has_trial_period: _winrt.Boolean
    trial_period: _winrt.UInt32
    trial_period_unit: StoreDurationUnit
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreSubscriptionInfo: ...

class StoreUninstallStorePackageResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: StoreUninstallStorePackageStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreUninstallStorePackageResult: ...

class StoreVideo(_winrt.Object):
    caption: str
    height: _winrt.UInt32
    preview_image: typing.Optional[StoreImage]
    uri: typing.Optional[winsdk.windows.foundation.Uri]
    video_purpose_tag: str
    width: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> StoreVideo: ...

