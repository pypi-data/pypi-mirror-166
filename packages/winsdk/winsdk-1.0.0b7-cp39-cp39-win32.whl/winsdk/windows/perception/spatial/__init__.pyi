# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.7

import enum
import datetime
import sys
import types
import typing

import winsdk._winrt as _winrt
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.foundation.numerics
import winsdk.windows.perception
import winsdk.windows.storage.streams
import winsdk.windows.system.remotesystems

class SpatialAnchorExportPurpose(enum.IntEnum):
    RELOCALIZATION = 0
    SHARING = 1

class SpatialEntityWatcherStatus(enum.IntEnum):
    CREATED = 0
    STARTED = 1
    ENUMERATION_COMPLETED = 2
    STOPPING = 3
    STOPPED = 4
    ABORTED = 5

class SpatialLocatability(enum.IntEnum):
    UNAVAILABLE = 0
    ORIENTATION_ONLY = 1
    POSITIONAL_TRACKING_ACTIVATING = 2
    POSITIONAL_TRACKING_ACTIVE = 3
    POSITIONAL_TRACKING_INHIBITED = 4

class SpatialLookDirectionRange(enum.IntEnum):
    FORWARD_ONLY = 0
    OMNIDIRECTIONAL = 1

class SpatialMovementRange(enum.IntEnum):
    NO_MOVEMENT = 0
    BOUNDED = 1

class SpatialPerceptionAccessStatus(enum.IntEnum):
    UNSPECIFIED = 0
    ALLOWED = 1
    DENIED_BY_USER = 2
    DENIED_BY_SYSTEM = 3

Self = typing.TypeVar('Self')

class SpatialBoundingBox:
    center: winsdk.windows.foundation.numerics.Vector3
    extents: winsdk.windows.foundation.numerics.Vector3
    def __new__(cls: typing.Type[SpatialBoundingBox], center: winsdk.windows.foundation.numerics.Vector3, extents: winsdk.windows.foundation.numerics.Vector3) -> SpatialBoundingBox: ...

class SpatialBoundingFrustum:
    near: winsdk.windows.foundation.numerics.Plane
    far: winsdk.windows.foundation.numerics.Plane
    right: winsdk.windows.foundation.numerics.Plane
    left: winsdk.windows.foundation.numerics.Plane
    top: winsdk.windows.foundation.numerics.Plane
    bottom: winsdk.windows.foundation.numerics.Plane
    def __new__(cls: typing.Type[SpatialBoundingFrustum], near: winsdk.windows.foundation.numerics.Plane, far: winsdk.windows.foundation.numerics.Plane, right: winsdk.windows.foundation.numerics.Plane, left: winsdk.windows.foundation.numerics.Plane, top: winsdk.windows.foundation.numerics.Plane, bottom: winsdk.windows.foundation.numerics.Plane) -> SpatialBoundingFrustum: ...

class SpatialBoundingOrientedBox:
    center: winsdk.windows.foundation.numerics.Vector3
    extents: winsdk.windows.foundation.numerics.Vector3
    orientation: winsdk.windows.foundation.numerics.Quaternion
    def __new__(cls: typing.Type[SpatialBoundingOrientedBox], center: winsdk.windows.foundation.numerics.Vector3, extents: winsdk.windows.foundation.numerics.Vector3, orientation: winsdk.windows.foundation.numerics.Quaternion) -> SpatialBoundingOrientedBox: ...

class SpatialBoundingSphere:
    center: winsdk.windows.foundation.numerics.Vector3
    radius: _winrt.Single
    def __new__(cls: typing.Type[SpatialBoundingSphere], center: winsdk.windows.foundation.numerics.Vector3, radius: _winrt.Single) -> SpatialBoundingSphere: ...

class SpatialRay:
    origin: winsdk.windows.foundation.numerics.Vector3
    direction: winsdk.windows.foundation.numerics.Vector3
    def __new__(cls: typing.Type[SpatialRay], origin: winsdk.windows.foundation.numerics.Vector3, direction: winsdk.windows.foundation.numerics.Vector3) -> SpatialRay: ...

class SpatialAnchor(_winrt.Object):
    coordinate_system: typing.Optional[SpatialCoordinateSystem]
    raw_coordinate_system: typing.Optional[SpatialCoordinateSystem]
    removed_by_user: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchor: ...
    @typing.overload
    @staticmethod
    def try_create_relative_to(coordinate_system: typing.Optional[SpatialCoordinateSystem]) -> typing.Optional[SpatialAnchor]: ...
    @typing.overload
    @staticmethod
    def try_create_relative_to(coordinate_system: typing.Optional[SpatialCoordinateSystem], position: winsdk.windows.foundation.numerics.Vector3) -> typing.Optional[SpatialAnchor]: ...
    @typing.overload
    @staticmethod
    def try_create_relative_to(coordinate_system: typing.Optional[SpatialCoordinateSystem], position: winsdk.windows.foundation.numerics.Vector3, orientation: winsdk.windows.foundation.numerics.Quaternion) -> typing.Optional[SpatialAnchor]: ...
    def add_raw_coordinate_system_adjusted(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialAnchor, SpatialAnchorRawCoordinateSystemAdjustedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_raw_coordinate_system_adjusted(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class SpatialAnchorExportSufficiency(_winrt.Object):
    is_minimally_sufficient: _winrt.Boolean
    recommended_sufficiency_level: _winrt.Double
    sufficiency_level: _winrt.Double
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchorExportSufficiency: ...

class SpatialAnchorExporter(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchorExporter: ...
    def get_anchor_export_sufficiency_async(self, anchor: typing.Optional[SpatialAnchor], purpose: SpatialAnchorExportPurpose) -> winsdk.windows.foundation.IAsyncOperation[SpatialAnchorExportSufficiency]: ...
    @staticmethod
    def get_default() -> typing.Optional[SpatialAnchorExporter]: ...
    @staticmethod
    def request_access_async() -> winsdk.windows.foundation.IAsyncOperation[SpatialPerceptionAccessStatus]: ...
    def try_export_anchor_async(self, anchor: typing.Optional[SpatialAnchor], purpose: SpatialAnchorExportPurpose, stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...

class SpatialAnchorManager(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchorManager: ...
    @staticmethod
    def request_store_async() -> winsdk.windows.foundation.IAsyncOperation[SpatialAnchorStore]: ...

class SpatialAnchorRawCoordinateSystemAdjustedEventArgs(_winrt.Object):
    old_raw_coordinate_system_to_new_raw_coordinate_system_transform: winsdk.windows.foundation.numerics.Matrix4x4
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchorRawCoordinateSystemAdjustedEventArgs: ...

class SpatialAnchorStore(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchorStore: ...
    def clear(self) -> None: ...
    def get_all_saved_anchors(self) -> typing.Optional[winsdk.windows.foundation.collections.IMapView[str, SpatialAnchor]]: ...
    def remove(self, id: str) -> None: ...
    def try_save(self, id: str, anchor: typing.Optional[SpatialAnchor]) -> _winrt.Boolean: ...

class SpatialAnchorTransferManager(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAnchorTransferManager: ...
    @staticmethod
    def request_access_async() -> winsdk.windows.foundation.IAsyncOperation[SpatialPerceptionAccessStatus]: ...
    @staticmethod
    def try_export_anchors_async(anchors: typing.Iterable[winsdk.windows.foundation.collections.IKeyValuePair[str, SpatialAnchor]], stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]) -> winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]: ...
    @staticmethod
    def try_import_anchors_async(stream: typing.Optional[winsdk.windows.storage.streams.IInputStream]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IMapView[str, SpatialAnchor]]: ...

class SpatialBoundingVolume(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialBoundingVolume: ...
    @staticmethod
    def from_box(coordinate_system: typing.Optional[SpatialCoordinateSystem], box: SpatialBoundingBox) -> typing.Optional[SpatialBoundingVolume]: ...
    @staticmethod
    def from_frustum(coordinate_system: typing.Optional[SpatialCoordinateSystem], frustum: SpatialBoundingFrustum) -> typing.Optional[SpatialBoundingVolume]: ...
    @staticmethod
    def from_oriented_box(coordinate_system: typing.Optional[SpatialCoordinateSystem], box: SpatialBoundingOrientedBox) -> typing.Optional[SpatialBoundingVolume]: ...
    @staticmethod
    def from_sphere(coordinate_system: typing.Optional[SpatialCoordinateSystem], sphere: SpatialBoundingSphere) -> typing.Optional[SpatialBoundingVolume]: ...

class SpatialCoordinateSystem(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialCoordinateSystem: ...
    def try_get_transform_to(self, target: typing.Optional[SpatialCoordinateSystem]) -> typing.Optional[typing.Optional[winsdk.windows.foundation.numerics.Matrix4x4]]: ...

class SpatialEntity(_winrt.Object):
    anchor: typing.Optional[SpatialAnchor]
    id: str
    properties: typing.Optional[winsdk.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialEntity: ...
    @typing.overload
    def __new__(cls: typing.Type[SpatialEntity], spatial_anchor: typing.Optional[SpatialAnchor]) -> SpatialEntity:...
    @typing.overload
    def __new__(cls: typing.Type[SpatialEntity], spatial_anchor: typing.Optional[SpatialAnchor], property_set: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> SpatialEntity:...

class SpatialEntityAddedEventArgs(_winrt.Object):
    entity: typing.Optional[SpatialEntity]
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialEntityAddedEventArgs: ...

class SpatialEntityRemovedEventArgs(_winrt.Object):
    entity: typing.Optional[SpatialEntity]
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialEntityRemovedEventArgs: ...

class SpatialEntityStore(_winrt.Object):
    is_supported: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialEntityStore: ...
    def create_entity_watcher(self) -> typing.Optional[SpatialEntityWatcher]: ...
    def remove_async(self, entity: typing.Optional[SpatialEntity]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def save_async(self, entity: typing.Optional[SpatialEntity]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @staticmethod
    def try_get(session: typing.Optional[winsdk.windows.system.remotesystems.RemoteSystemSession]) -> typing.Optional[SpatialEntityStore]: ...

class SpatialEntityUpdatedEventArgs(_winrt.Object):
    entity: typing.Optional[SpatialEntity]
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialEntityUpdatedEventArgs: ...

class SpatialEntityWatcher(_winrt.Object):
    status: SpatialEntityWatcherStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialEntityWatcher: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_added(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityAddedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_added(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_enumeration_completed(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialEntityWatcher, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_enumeration_completed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_removed(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityRemovedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_removed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_updated(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialEntityWatcher, SpatialEntityUpdatedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_updated(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class SpatialLocation(_winrt.Object):
    absolute_angular_acceleration: winsdk.windows.foundation.numerics.Quaternion
    absolute_angular_velocity: winsdk.windows.foundation.numerics.Quaternion
    absolute_linear_acceleration: winsdk.windows.foundation.numerics.Vector3
    absolute_linear_velocity: winsdk.windows.foundation.numerics.Vector3
    orientation: winsdk.windows.foundation.numerics.Quaternion
    position: winsdk.windows.foundation.numerics.Vector3
    absolute_angular_acceleration_axis_angle: winsdk.windows.foundation.numerics.Vector3
    absolute_angular_velocity_axis_angle: winsdk.windows.foundation.numerics.Vector3
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialLocation: ...

class SpatialLocator(_winrt.Object):
    locatability: SpatialLocatability
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialLocator: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winsdk.windows.foundation.numerics.Vector3) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winsdk.windows.foundation.numerics.Vector3, relative_orientation: winsdk.windows.foundation.numerics.Quaternion) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_attached_frame_of_reference_at_current_heading(self, relative_position: winsdk.windows.foundation.numerics.Vector3, relative_orientation: winsdk.windows.foundation.numerics.Quaternion, relative_heading_in_radians: _winrt.Double) -> typing.Optional[SpatialLocatorAttachedFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winsdk.windows.foundation.numerics.Vector3) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winsdk.windows.foundation.numerics.Vector3, relative_orientation: winsdk.windows.foundation.numerics.Quaternion) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @typing.overload
    def create_stationary_frame_of_reference_at_current_location(self, relative_position: winsdk.windows.foundation.numerics.Vector3, relative_orientation: winsdk.windows.foundation.numerics.Quaternion, relative_heading_in_radians: _winrt.Double) -> typing.Optional[SpatialStationaryFrameOfReference]: ...
    @staticmethod
    def get_default() -> typing.Optional[SpatialLocator]: ...
    def try_locate_at_timestamp(self, timestamp: typing.Optional[winsdk.windows.perception.PerceptionTimestamp], coordinate_system: typing.Optional[SpatialCoordinateSystem]) -> typing.Optional[SpatialLocation]: ...
    def add_locatability_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialLocator, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_locatability_changed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_positional_tracking_deactivating(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialLocator, SpatialLocatorPositionalTrackingDeactivatingEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_positional_tracking_deactivating(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class SpatialLocatorAttachedFrameOfReference(_winrt.Object):
    relative_position: winsdk.windows.foundation.numerics.Vector3
    relative_orientation: winsdk.windows.foundation.numerics.Quaternion
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialLocatorAttachedFrameOfReference: ...
    def adjust_heading(self, heading_offset_in_radians: _winrt.Double) -> None: ...
    def get_stationary_coordinate_system_at_timestamp(self, timestamp: typing.Optional[winsdk.windows.perception.PerceptionTimestamp]) -> typing.Optional[SpatialCoordinateSystem]: ...
    def try_get_relative_heading_at_timestamp(self, timestamp: typing.Optional[winsdk.windows.perception.PerceptionTimestamp]) -> typing.Optional[typing.Optional[_winrt.Double]]: ...

class SpatialLocatorPositionalTrackingDeactivatingEventArgs(_winrt.Object):
    canceled: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialLocatorPositionalTrackingDeactivatingEventArgs: ...

class SpatialStageFrameOfReference(_winrt.Object):
    coordinate_system: typing.Optional[SpatialCoordinateSystem]
    look_direction_range: SpatialLookDirectionRange
    movement_range: SpatialMovementRange
    current: typing.Optional[SpatialStageFrameOfReference]
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialStageFrameOfReference: ...
    def get_coordinate_system_at_current_location(self, locator: typing.Optional[SpatialLocator]) -> typing.Optional[SpatialCoordinateSystem]: ...
    @staticmethod
    def request_new_stage_async() -> winsdk.windows.foundation.IAsyncOperation[SpatialStageFrameOfReference]: ...
    def try_get_movement_bounds(self, coordinate_system: typing.Optional[SpatialCoordinateSystem]) -> winsdk.windows.foundation.numerics.Vector3: ...
    @staticmethod
    def add_current_changed(handler: winsdk.windows.foundation.EventHandler[_winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    @staticmethod
    def remove_current_changed(cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class SpatialStationaryFrameOfReference(_winrt.Object):
    coordinate_system: typing.Optional[SpatialCoordinateSystem]
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialStationaryFrameOfReference: ...

