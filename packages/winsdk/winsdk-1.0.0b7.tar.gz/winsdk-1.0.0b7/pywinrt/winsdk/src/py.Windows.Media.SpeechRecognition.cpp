// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.7

#include "pybase.h"
#include "py.Windows.Media.SpeechRecognition.h"


namespace py::cpp::Windows::Media::SpeechRecognition
{
    struct module_state
    {
        PyObject* type_SpeechContinuousRecognitionMode;
        PyObject* type_SpeechRecognitionAudioProblem;
        PyObject* type_SpeechRecognitionConfidence;
        PyObject* type_SpeechRecognitionConstraintProbability;
        PyObject* type_SpeechRecognitionConstraintType;
        PyObject* type_SpeechRecognitionResultStatus;
        PyObject* type_SpeechRecognitionScenario;
        PyObject* type_SpeechRecognizerState;
        PyTypeObject* type_SpeechContinuousRecognitionCompletedEventArgs;
        PyTypeObject* type_SpeechContinuousRecognitionResultGeneratedEventArgs;
        PyTypeObject* type_SpeechContinuousRecognitionSession;
        PyTypeObject* type_SpeechRecognitionCompilationResult;
        PyTypeObject* type_SpeechRecognitionGrammarFileConstraint;
        PyTypeObject* type_SpeechRecognitionHypothesis;
        PyTypeObject* type_SpeechRecognitionHypothesisGeneratedEventArgs;
        PyTypeObject* type_SpeechRecognitionListConstraint;
        PyTypeObject* type_SpeechRecognitionQualityDegradingEventArgs;
        PyTypeObject* type_SpeechRecognitionResult;
        PyTypeObject* type_SpeechRecognitionSemanticInterpretation;
        PyTypeObject* type_SpeechRecognitionTopicConstraint;
        PyTypeObject* type_SpeechRecognitionVoiceCommandDefinitionConstraint;
        PyTypeObject* type_SpeechRecognizer;
        PyTypeObject* type_SpeechRecognizerStateChangedEventArgs;
        PyTypeObject* type_SpeechRecognizerTimeouts;
        PyTypeObject* type_SpeechRecognizerUIOptions;
        PyTypeObject* type_VoiceCommandManager;
        PyTypeObject* type_VoiceCommandSet;
        PyTypeObject* type_ISpeechRecognitionConstraint;
    };

    static PyObject* register_SpeechContinuousRecognitionMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechContinuousRecognitionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechContinuousRecognitionMode = type;
        Py_INCREF(state->type_SpeechContinuousRecognitionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognitionAudioProblem(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognitionAudioProblem)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognitionAudioProblem = type;
        Py_INCREF(state->type_SpeechRecognitionAudioProblem);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognitionConfidence(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognitionConfidence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognitionConfidence = type;
        Py_INCREF(state->type_SpeechRecognitionConfidence);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognitionConstraintProbability(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognitionConstraintProbability)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognitionConstraintProbability = type;
        Py_INCREF(state->type_SpeechRecognitionConstraintProbability);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognitionConstraintType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognitionConstraintType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognitionConstraintType = type;
        Py_INCREF(state->type_SpeechRecognitionConstraintType);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognitionResultStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognitionResultStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognitionResultStatus = type;
        Py_INCREF(state->type_SpeechRecognitionResultStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognitionScenario(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognitionScenario)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognitionScenario = type;
        Py_INCREF(state->type_SpeechRecognitionScenario);


        Py_RETURN_NONE;
    }

    static PyObject* register_SpeechRecognizerState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SpeechRecognizerState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SpeechRecognizerState = type;
        Py_INCREF(state->type_SpeechRecognizerState);


        Py_RETURN_NONE;
    }

    // ----- SpeechContinuousRecognitionCompletedEventArgs class --------------------
    constexpr const char* const type_name_SpeechContinuousRecognitionCompletedEventArgs = "SpeechContinuousRecognitionCompletedEventArgs";

    static PyObject* _new_SpeechContinuousRecognitionCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechContinuousRecognitionCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionCompletedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionCompletedEventArgs_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(SpeechContinuousRecognitionCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionCompletedEventArgs },
        { },
    };

    static PyType_Spec type_spec_SpeechContinuousRecognitionCompletedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionCompletedEventArgs
    };

    // ----- SpeechContinuousRecognitionResultGeneratedEventArgs class --------------------
    constexpr const char* const type_name_SpeechContinuousRecognitionResultGeneratedEventArgs = "SpeechContinuousRecognitionResultGeneratedEventArgs";

    static PyObject* _new_SpeechContinuousRecognitionResultGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechContinuousRecognitionResultGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionResultGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "result", reinterpret_cast<getter>(SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { },
    };

    static PyType_Spec type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs
    };

    // ----- SpeechContinuousRecognitionSession class --------------------
    constexpr const char* const type_name_SpeechContinuousRecognitionSession = "SpeechContinuousRecognitionSession";

    static PyObject* _new_SpeechContinuousRecognitionSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechContinuousRecognitionSession);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechContinuousRecognitionSession_CancelAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"CancelAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CancelAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_PauseAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"PauseAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_Resume(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Resume", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StartAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StartAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StartAsync", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode>(args, 0);

                return py::convert(self->obj.StartAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StopAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"StopAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"AutoStopSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoStopSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"AutoStopSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AutoStopSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"ResultGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>(arg);

            return py::convert(self->obj.ResultGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession", L"ResultGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResultGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionSession[] = {
        { "cancel_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_CancelAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_Resume), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StopAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_Completed), METH_O, nullptr },
        { "add_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_ResultGenerated), METH_O, nullptr },
        { "remove_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_ResultGenerated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionSession[] = {
        { "auto_stop_silence_timeout", reinterpret_cast<getter>(SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout), reinterpret_cast<setter>(SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionSession[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionSession },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionSession },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionSession },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionSession },
        { },
    };

    static PyType_Spec type_spec_SpeechContinuousRecognitionSession =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionSession",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionSession
    };

    // ----- SpeechRecognitionCompilationResult class --------------------
    constexpr const char* const type_name_SpeechRecognitionCompilationResult = "SpeechRecognitionCompilationResult";

    static PyObject* _new_SpeechRecognitionCompilationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionCompilationResult);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionCompilationResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionCompilationResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionCompilationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionCompilationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionCompilationResult[] = {
        { "status", reinterpret_cast<getter>(SpeechRecognitionCompilationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionCompilationResult[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionCompilationResult },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionCompilationResult },
        { Py_tp_methods, _methods_SpeechRecognitionCompilationResult },
        { Py_tp_getset, _getset_SpeechRecognitionCompilationResult },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionCompilationResult =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionCompilationResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionCompilationResult
    };

    // ----- SpeechRecognitionGrammarFileConstraint class --------------------
    constexpr const char* const type_name_SpeechRecognitionGrammarFileConstraint = "SpeechRecognitionGrammarFileConstraint";

    static PyObject* _new_SpeechRecognitionGrammarFileConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionGrammarFileConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_GrammarFile(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionGrammarFileConstraint", L"GrammarFile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GrammarFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionGrammarFileConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionGrammarFileConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionGrammarFileConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Type), nullptr, nullptr, nullptr },
        { "grammar_file", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_GrammarFile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionGrammarFileConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionGrammarFileConstraint },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionGrammarFileConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionGrammarFileConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionGrammarFileConstraint
    };

    // ----- SpeechRecognitionHypothesis class --------------------
    constexpr const char* const type_name_SpeechRecognitionHypothesis = "SpeechRecognitionHypothesis";

    static PyObject* _new_SpeechRecognitionHypothesis(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionHypothesis);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionHypothesis_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesis[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesis), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesis[] = {
        { "text", reinterpret_cast<getter>(SpeechRecognitionHypothesis_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesis[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionHypothesis },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionHypothesis },
        { Py_tp_methods, _methods_SpeechRecognitionHypothesis },
        { Py_tp_getset, _getset_SpeechRecognitionHypothesis },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionHypothesis =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionHypothesis",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesis
    };

    // ----- SpeechRecognitionHypothesisGeneratedEventArgs class --------------------
    constexpr const char* const type_name_SpeechRecognitionHypothesisGeneratedEventArgs = "SpeechRecognitionHypothesisGeneratedEventArgs";

    static PyObject* _new_SpeechRecognitionHypothesisGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionHypothesisGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs", L"Hypothesis"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hypothesis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesisGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "hypothesis", reinterpret_cast<getter>(SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_methods, _methods_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_getset, _getset_SpeechRecognitionHypothesisGeneratedEventArgs },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionHypothesisGeneratedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs
    };

    // ----- SpeechRecognitionListConstraint class --------------------
    constexpr const char* const type_name_SpeechRecognitionListConstraint = "SpeechRecognitionListConstraint";

    static PyObject* _new_SpeechRecognitionListConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionListConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionListConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Commands(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint", L"Commands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionListConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionListConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionListConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Type), nullptr, nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Commands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionListConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionListConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionListConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionListConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionListConstraint },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionListConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionListConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionListConstraint
    };

    // ----- SpeechRecognitionQualityDegradingEventArgs class --------------------
    constexpr const char* const type_name_SpeechRecognitionQualityDegradingEventArgs = "SpeechRecognitionQualityDegradingEventArgs";

    static PyObject* _new_SpeechRecognitionQualityDegradingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionQualityDegradingEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionQualityDegradingEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionQualityDegradingEventArgs_get_Problem(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs", L"Problem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Problem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionQualityDegradingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "problem", reinterpret_cast<getter>(SpeechRecognitionQualityDegradingEventArgs_get_Problem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionQualityDegradingEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_methods, _methods_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_getset, _getset_SpeechRecognitionQualityDegradingEventArgs },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionQualityDegradingEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionQualityDegradingEventArgs
    };

    // ----- SpeechRecognitionResult class --------------------
    constexpr const char* const type_name_SpeechRecognitionResult = "SpeechRecognitionResult";

    static PyObject* _new_SpeechRecognitionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionResult);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionResult_GetAlternates(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"GetAlternates", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Confidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Confidence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Constraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Constraint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Constraint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RawConfidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"RawConfidence"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawConfidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RulePath(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"RulePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RulePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_SemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"SemanticInterpretation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SemanticInterpretation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseDuration(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"PhraseDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhraseDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseStartTime(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionResult", L"PhraseStartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhraseStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionResult[] = {
        { "get_alternates", reinterpret_cast<PyCFunction>(SpeechRecognitionResult_GetAlternates), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionResult[] = {
        { "confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_Confidence), nullptr, nullptr, nullptr },
        { "constraint", reinterpret_cast<getter>(SpeechRecognitionResult_get_Constraint), nullptr, nullptr, nullptr },
        { "raw_confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_RawConfidence), nullptr, nullptr, nullptr },
        { "rule_path", reinterpret_cast<getter>(SpeechRecognitionResult_get_RulePath), nullptr, nullptr, nullptr },
        { "semantic_interpretation", reinterpret_cast<getter>(SpeechRecognitionResult_get_SemanticInterpretation), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SpeechRecognitionResult_get_Status), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechRecognitionResult_get_Text), nullptr, nullptr, nullptr },
        { "phrase_duration", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseDuration), nullptr, nullptr, nullptr },
        { "phrase_start_time", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseStartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionResult[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionResult },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionResult },
        { Py_tp_methods, _methods_SpeechRecognitionResult },
        { Py_tp_getset, _getset_SpeechRecognitionResult },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionResult =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionResult
    };

    // ----- SpeechRecognitionSemanticInterpretation class --------------------
    constexpr const char* const type_name_SpeechRecognitionSemanticInterpretation = "SpeechRecognitionSemanticInterpretation";

    static PyObject* _new_SpeechRecognitionSemanticInterpretation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionSemanticInterpretation);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionSemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionSemanticInterpretation_get_Properties(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionSemanticInterpretation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionSemanticInterpretation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionSemanticInterpretation[] = {
        { "properties", reinterpret_cast<getter>(SpeechRecognitionSemanticInterpretation_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionSemanticInterpretation[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionSemanticInterpretation },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionSemanticInterpretation },
        { Py_tp_methods, _methods_SpeechRecognitionSemanticInterpretation },
        { Py_tp_getset, _getset_SpeechRecognitionSemanticInterpretation },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionSemanticInterpretation =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionSemanticInterpretation",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionSemanticInterpretation
    };

    // ----- SpeechRecognitionTopicConstraint class --------------------
    constexpr const char* const type_name_SpeechRecognitionTopicConstraint = "SpeechRecognitionTopicConstraint";

    static PyObject* _new_SpeechRecognitionTopicConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionTopicConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Scenario(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"Scenario"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scenario());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_TopicHint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionTopicConstraint", L"TopicHint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TopicHint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionTopicConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionTopicConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionTopicConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Type), nullptr, nullptr, nullptr },
        { "scenario", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Scenario), nullptr, nullptr, nullptr },
        { "topic_hint", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_TopicHint), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionTopicConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionTopicConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionTopicConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionTopicConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionTopicConstraint },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionTopicConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionTopicConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionTopicConstraint
    };

    // ----- SpeechRecognitionVoiceCommandDefinitionConstraint class --------------------
    constexpr const char* const type_name_SpeechRecognitionVoiceCommandDefinitionConstraint = "SpeechRecognitionVoiceCommandDefinitionConstraint";

    static PyObject* _new_SpeechRecognitionVoiceCommandDefinitionConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognitionVoiceCommandDefinitionConstraint);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionVoiceCommandDefinitionConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint
    };

    // ----- SpeechRecognizer class --------------------
    constexpr const char* const type_name_SpeechRecognizer = "SpeechRecognizer";

    static PyObject* _new_SpeechRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizer_Close(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Close", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_CompileConstraintsAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"CompileConstraintsAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CompileConstraintsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognizeAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RecognizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeWithUIAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognizeWithUIAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RecognizeWithUIAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_StopRecognitionAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StopRecognitionAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StopRecognitionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_TrySetSystemSpeechLanguageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"TrySetSystemSpeechLanguageAsync", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::TrySetSystemSpeechLanguageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Constraints(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Constraints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Constraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_CurrentLanguage(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"CurrentLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Timeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"Timeouts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timeouts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_UIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"UIOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UIOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_ContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"ContinuousRecognitionSession"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContinuousRecognitionSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedGrammarLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SupportedGrammarLanguages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedGrammarLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedTopicLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SupportedTopicLanguages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedTopicLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SystemSpeechLanguage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"SystemSpeechLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SystemSpeechLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognitionQualityDegrading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>(arg);

            return py::convert(self->obj.RecognitionQualityDegrading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"RecognitionQualityDegrading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionQualityDegrading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"HypothesisGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>(arg);

            return py::convert(self->obj.HypothesisGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizer", L"HypothesisGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HypothesisGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizer[] = {
        { "close", reinterpret_cast<PyCFunction>(SpeechRecognizer_Close), METH_VARARGS, nullptr },
        { "compile_constraints_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_CompileConstraintsAsync), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeAsync), METH_VARARGS, nullptr },
        { "recognize_with_u_i_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeWithUIAsync), METH_VARARGS, nullptr },
        { "stop_recognition_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_StopRecognitionAsync), METH_VARARGS, nullptr },
        { "try_set_system_speech_language_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_TrySetSystemSpeechLanguageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_grammar_languages", reinterpret_cast<PyCFunction>(SpeechRecognizer_get_SupportedGrammarLanguages), METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_topic_languages", reinterpret_cast<PyCFunction>(SpeechRecognizer_get_SupportedTopicLanguages), METH_NOARGS | METH_STATIC, nullptr },
        { "get_system_speech_language", reinterpret_cast<PyCFunction>(SpeechRecognizer_get_SystemSpeechLanguage), METH_NOARGS | METH_STATIC, nullptr },
        { "add_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_RecognitionQualityDegrading), METH_O, nullptr },
        { "remove_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_RecognitionQualityDegrading), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_StateChanged), METH_O, nullptr },
        { "add_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_HypothesisGenerated), METH_O, nullptr },
        { "remove_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_HypothesisGenerated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SpeechRecognizer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SpeechRecognizer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizer[] = {
        { "constraints", reinterpret_cast<getter>(SpeechRecognizer_get_Constraints), nullptr, nullptr, nullptr },
        { "current_language", reinterpret_cast<getter>(SpeechRecognizer_get_CurrentLanguage), nullptr, nullptr, nullptr },
        { "timeouts", reinterpret_cast<getter>(SpeechRecognizer_get_Timeouts), nullptr, nullptr, nullptr },
        { "u_i_options", reinterpret_cast<getter>(SpeechRecognizer_get_UIOptions), nullptr, nullptr, nullptr },
        { "continuous_recognition_session", reinterpret_cast<getter>(SpeechRecognizer_get_ContinuousRecognitionSession), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(SpeechRecognizer_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizer[] = 
    {
        { Py_tp_new, _new_SpeechRecognizer },
        { Py_tp_dealloc, _dealloc_SpeechRecognizer },
        { Py_tp_methods, _methods_SpeechRecognizer },
        { Py_tp_getset, _getset_SpeechRecognizer },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizer =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizer",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizer
    };

    // ----- SpeechRecognizerStateChangedEventArgs class --------------------
    constexpr const char* const type_name_SpeechRecognizerStateChangedEventArgs = "SpeechRecognizerStateChangedEventArgs";

    static PyObject* _new_SpeechRecognizerStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognizerStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerStateChangedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerStateChangedEventArgs_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(SpeechRecognizerStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_methods, _methods_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_getset, _getset_SpeechRecognizerStateChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizerStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizerStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerStateChangedEventArgs
    };

    // ----- SpeechRecognizerTimeouts class --------------------
    constexpr const char* const type_name_SpeechRecognizerTimeouts = "SpeechRecognizerTimeouts";

    static PyObject* _new_SpeechRecognizerTimeouts(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognizerTimeouts);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerTimeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerTimeouts_get_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"InitialSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitialSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"InitialSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InitialSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"EndSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"EndSilenceTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EndSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"BabbleTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BabbleTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts", L"BabbleTimeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BabbleTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerTimeouts[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerTimeouts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerTimeouts[] = {
        { "initial_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_InitialSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_InitialSilenceTimeout), nullptr, nullptr },
        { "end_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_EndSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_EndSilenceTimeout), nullptr, nullptr },
        { "babble_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_BabbleTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_BabbleTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerTimeouts[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerTimeouts },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerTimeouts },
        { Py_tp_methods, _methods_SpeechRecognizerTimeouts },
        { Py_tp_getset, _getset_SpeechRecognizerTimeouts },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizerTimeouts =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizerTimeouts",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerTimeouts
    };

    // ----- SpeechRecognizerUIOptions class --------------------
    constexpr const char* const type_name_SpeechRecognizerUIOptions = "SpeechRecognizerUIOptions";

    static PyObject* _new_SpeechRecognizerUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SpeechRecognizerUIOptions);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerUIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechRecognizerUIOptions_get_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ShowConfirmation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowConfirmation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ShowConfirmation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowConfirmation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"IsReadBackEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadBackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"IsReadBackEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReadBackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ExampleText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExampleText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"ExampleText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExampleText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"AudiblePrompt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudiblePrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions", L"AudiblePrompt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudiblePrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerUIOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerUIOptions[] = {
        { "show_confirmation", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ShowConfirmation), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ShowConfirmation), nullptr, nullptr },
        { "is_read_back_enabled", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_IsReadBackEnabled), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_IsReadBackEnabled), nullptr, nullptr },
        { "example_text", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ExampleText), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ExampleText), nullptr, nullptr },
        { "audible_prompt", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_AudiblePrompt), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_AudiblePrompt), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerUIOptions[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerUIOptions },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerUIOptions },
        { Py_tp_methods, _methods_SpeechRecognizerUIOptions },
        { Py_tp_getset, _getset_SpeechRecognizerUIOptions },
        { },
    };

    static PyType_Spec type_spec_SpeechRecognizerUIOptions =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizerUIOptions",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerUIOptions
    };

    // ----- VoiceCommandManager class --------------------
    constexpr const char* const type_name_VoiceCommandManager = "VoiceCommandManager";

    static PyObject* _new_VoiceCommandManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VoiceCommandManager);
        return nullptr;
    }

    static PyObject* VoiceCommandManager_InstallCommandSetsFromStorageFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.VoiceCommandManager", L"InstallCommandSetsFromStorageFileAsync", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::SpeechRecognition::VoiceCommandManager::InstallCommandSetsFromStorageFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoiceCommandManager_get_InstalledCommandSets(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.VoiceCommandManager", L"InstalledCommandSets"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::VoiceCommandManager::InstalledCommandSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandManager[] = {
        { "install_command_sets_from_storage_file_async", reinterpret_cast<PyCFunction>(VoiceCommandManager_InstallCommandSetsFromStorageFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_installed_command_sets", reinterpret_cast<PyCFunction>(VoiceCommandManager_get_InstalledCommandSets), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoiceCommandManager[] = {
        { }
    };

    static PyType_Slot _type_slots_VoiceCommandManager[] = 
    {
        { Py_tp_new, _new_VoiceCommandManager },
        { Py_tp_methods, _methods_VoiceCommandManager },
        { Py_tp_getset, _getset_VoiceCommandManager },
        { },
    };

    static PyType_Spec type_spec_VoiceCommandManager =
    {
        "_winsdk_Windows_Media_SpeechRecognition.VoiceCommandManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandManager
    };

    // ----- VoiceCommandSet class --------------------
    constexpr const char* const type_name_VoiceCommandSet = "VoiceCommandSet";

    static PyObject* _new_VoiceCommandSet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VoiceCommandSet);
        return nullptr;
    }

    static void _dealloc_VoiceCommandSet(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoiceCommandSet_SetPhraseListAsync(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.SpeechRecognition.VoiceCommandSet", L"SetPhraseListAsync", 2))
            {
                PyErr_SetString(PyExc_AttributeError, "method 2 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.SetPhraseListAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoiceCommandSet_get_Language(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.VoiceCommandSet", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandSet_get_Name(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.VoiceCommandSet", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VoiceCommandSet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::VoiceCommandSet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandSet[] = {
        { "set_phrase_list_async", reinterpret_cast<PyCFunction>(VoiceCommandSet_SetPhraseListAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoiceCommandSet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoiceCommandSet[] = {
        { "language", reinterpret_cast<getter>(VoiceCommandSet_get_Language), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VoiceCommandSet_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoiceCommandSet[] = 
    {
        { Py_tp_new, _new_VoiceCommandSet },
        { Py_tp_dealloc, _dealloc_VoiceCommandSet },
        { Py_tp_methods, _methods_VoiceCommandSet },
        { Py_tp_getset, _getset_VoiceCommandSet },
        { },
    };

    static PyType_Spec type_spec_VoiceCommandSet =
    {
        "_winsdk_Windows_Media_SpeechRecognition.VoiceCommandSet",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::VoiceCommandSet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandSet
    };

    // ----- ISpeechRecognitionConstraint interface --------------------
    constexpr const char* const type_name_ISpeechRecognitionConstraint = "ISpeechRecognitionConstraint";

    static PyObject* _new_ISpeechRecognitionConstraint(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ISpeechRecognitionConstraint);
        return nullptr;
    }

    static void _dealloc_ISpeechRecognitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpeechRecognitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Probability"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpeechRecognitionConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpeechRecognitionConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISpeechRecognitionConstraint[] = {
        { "is_enabled", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_IsEnabled), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Probability), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Probability), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Tag), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Tag), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISpeechRecognitionConstraint[] = 
    {
        { Py_tp_new, _new_ISpeechRecognitionConstraint },
        { Py_tp_dealloc, _dealloc_ISpeechRecognitionConstraint },
        { Py_tp_methods, _methods_ISpeechRecognitionConstraint },
        { Py_tp_getset, _getset_ISpeechRecognitionConstraint },
        { },
    };

    static PyType_Spec type_spec_ISpeechRecognitionConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.ISpeechRecognitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpeechRecognitionConstraint
    };

    // ----- Windows.Media.SpeechRecognition Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::SpeechRecognition");

    static PyMethodDef module_methods[] = {
        {"_register_SpeechContinuousRecognitionMode", register_SpeechContinuousRecognitionMode, METH_O, "registers type"},
        {"_register_SpeechRecognitionAudioProblem", register_SpeechRecognitionAudioProblem, METH_O, "registers type"},
        {"_register_SpeechRecognitionConfidence", register_SpeechRecognitionConfidence, METH_O, "registers type"},
        {"_register_SpeechRecognitionConstraintProbability", register_SpeechRecognitionConstraintProbability, METH_O, "registers type"},
        {"_register_SpeechRecognitionConstraintType", register_SpeechRecognitionConstraintType, METH_O, "registers type"},
        {"_register_SpeechRecognitionResultStatus", register_SpeechRecognitionResultStatus, METH_O, "registers type"},
        {"_register_SpeechRecognitionScenario", register_SpeechRecognitionScenario, METH_O, "registers type"},
        {"_register_SpeechRecognizerState", register_SpeechRecognizerState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_SpeechContinuousRecognitionMode);
        Py_VISIT(state->type_SpeechRecognitionAudioProblem);
        Py_VISIT(state->type_SpeechRecognitionConfidence);
        Py_VISIT(state->type_SpeechRecognitionConstraintProbability);
        Py_VISIT(state->type_SpeechRecognitionConstraintType);
        Py_VISIT(state->type_SpeechRecognitionResultStatus);
        Py_VISIT(state->type_SpeechRecognitionScenario);
        Py_VISIT(state->type_SpeechRecognizerState);
        Py_VISIT(state->type_SpeechContinuousRecognitionCompletedEventArgs);
        Py_VISIT(state->type_SpeechContinuousRecognitionResultGeneratedEventArgs);
        Py_VISIT(state->type_SpeechContinuousRecognitionSession);
        Py_VISIT(state->type_SpeechRecognitionCompilationResult);
        Py_VISIT(state->type_SpeechRecognitionGrammarFileConstraint);
        Py_VISIT(state->type_SpeechRecognitionHypothesis);
        Py_VISIT(state->type_SpeechRecognitionHypothesisGeneratedEventArgs);
        Py_VISIT(state->type_SpeechRecognitionListConstraint);
        Py_VISIT(state->type_SpeechRecognitionQualityDegradingEventArgs);
        Py_VISIT(state->type_SpeechRecognitionResult);
        Py_VISIT(state->type_SpeechRecognitionSemanticInterpretation);
        Py_VISIT(state->type_SpeechRecognitionTopicConstraint);
        Py_VISIT(state->type_SpeechRecognitionVoiceCommandDefinitionConstraint);
        Py_VISIT(state->type_SpeechRecognizer);
        Py_VISIT(state->type_SpeechRecognizerStateChangedEventArgs);
        Py_VISIT(state->type_SpeechRecognizerTimeouts);
        Py_VISIT(state->type_SpeechRecognizerUIOptions);
        Py_VISIT(state->type_VoiceCommandManager);
        Py_VISIT(state->type_VoiceCommandSet);
        Py_VISIT(state->type_ISpeechRecognitionConstraint);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_SpeechContinuousRecognitionMode);
        Py_CLEAR(state->type_SpeechRecognitionAudioProblem);
        Py_CLEAR(state->type_SpeechRecognitionConfidence);
        Py_CLEAR(state->type_SpeechRecognitionConstraintProbability);
        Py_CLEAR(state->type_SpeechRecognitionConstraintType);
        Py_CLEAR(state->type_SpeechRecognitionResultStatus);
        Py_CLEAR(state->type_SpeechRecognitionScenario);
        Py_CLEAR(state->type_SpeechRecognizerState);
        Py_CLEAR(state->type_SpeechContinuousRecognitionCompletedEventArgs);
        Py_CLEAR(state->type_SpeechContinuousRecognitionResultGeneratedEventArgs);
        Py_CLEAR(state->type_SpeechContinuousRecognitionSession);
        Py_CLEAR(state->type_SpeechRecognitionCompilationResult);
        Py_CLEAR(state->type_SpeechRecognitionGrammarFileConstraint);
        Py_CLEAR(state->type_SpeechRecognitionHypothesis);
        Py_CLEAR(state->type_SpeechRecognitionHypothesisGeneratedEventArgs);
        Py_CLEAR(state->type_SpeechRecognitionListConstraint);
        Py_CLEAR(state->type_SpeechRecognitionQualityDegradingEventArgs);
        Py_CLEAR(state->type_SpeechRecognitionResult);
        Py_CLEAR(state->type_SpeechRecognitionSemanticInterpretation);
        Py_CLEAR(state->type_SpeechRecognitionTopicConstraint);
        Py_CLEAR(state->type_SpeechRecognitionVoiceCommandDefinitionConstraint);
        Py_CLEAR(state->type_SpeechRecognizer);
        Py_CLEAR(state->type_SpeechRecognizerStateChangedEventArgs);
        Py_CLEAR(state->type_SpeechRecognizerTimeouts);
        Py_CLEAR(state->type_SpeechRecognizerUIOptions);
        Py_CLEAR(state->type_VoiceCommandManager);
        Py_CLEAR(state->type_VoiceCommandSet);
        Py_CLEAR(state->type_ISpeechRecognitionConstraint);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_SpeechRecognition",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::SpeechRecognition

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_SpeechRecognition(void) noexcept
{
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_SpeechContinuousRecognitionCompletedEventArgs = py::register_python_type(module.get(), type_name_SpeechContinuousRecognitionCompletedEventArgs, &type_spec_SpeechContinuousRecognitionCompletedEventArgs, bases.get());
    if (!state->type_SpeechContinuousRecognitionCompletedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechContinuousRecognitionCompletedEventArgs);

    state->type_SpeechContinuousRecognitionResultGeneratedEventArgs = py::register_python_type(module.get(), type_name_SpeechContinuousRecognitionResultGeneratedEventArgs, &type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs, bases.get());
    if (!state->type_SpeechContinuousRecognitionResultGeneratedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechContinuousRecognitionResultGeneratedEventArgs);

    state->type_SpeechContinuousRecognitionSession = py::register_python_type(module.get(), type_name_SpeechContinuousRecognitionSession, &type_spec_SpeechContinuousRecognitionSession, bases.get());
    if (!state->type_SpeechContinuousRecognitionSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechContinuousRecognitionSession);

    state->type_SpeechRecognitionCompilationResult = py::register_python_type(module.get(), type_name_SpeechRecognitionCompilationResult, &type_spec_SpeechRecognitionCompilationResult, bases.get());
    if (!state->type_SpeechRecognitionCompilationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionCompilationResult);

    state->type_SpeechRecognitionGrammarFileConstraint = py::register_python_type(module.get(), type_name_SpeechRecognitionGrammarFileConstraint, &type_spec_SpeechRecognitionGrammarFileConstraint, bases.get());
    if (!state->type_SpeechRecognitionGrammarFileConstraint)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionGrammarFileConstraint);

    state->type_SpeechRecognitionHypothesis = py::register_python_type(module.get(), type_name_SpeechRecognitionHypothesis, &type_spec_SpeechRecognitionHypothesis, bases.get());
    if (!state->type_SpeechRecognitionHypothesis)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionHypothesis);

    state->type_SpeechRecognitionHypothesisGeneratedEventArgs = py::register_python_type(module.get(), type_name_SpeechRecognitionHypothesisGeneratedEventArgs, &type_spec_SpeechRecognitionHypothesisGeneratedEventArgs, bases.get());
    if (!state->type_SpeechRecognitionHypothesisGeneratedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionHypothesisGeneratedEventArgs);

    state->type_SpeechRecognitionListConstraint = py::register_python_type(module.get(), type_name_SpeechRecognitionListConstraint, &type_spec_SpeechRecognitionListConstraint, bases.get());
    if (!state->type_SpeechRecognitionListConstraint)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionListConstraint);

    state->type_SpeechRecognitionQualityDegradingEventArgs = py::register_python_type(module.get(), type_name_SpeechRecognitionQualityDegradingEventArgs, &type_spec_SpeechRecognitionQualityDegradingEventArgs, bases.get());
    if (!state->type_SpeechRecognitionQualityDegradingEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionQualityDegradingEventArgs);

    state->type_SpeechRecognitionResult = py::register_python_type(module.get(), type_name_SpeechRecognitionResult, &type_spec_SpeechRecognitionResult, bases.get());
    if (!state->type_SpeechRecognitionResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionResult);

    state->type_SpeechRecognitionSemanticInterpretation = py::register_python_type(module.get(), type_name_SpeechRecognitionSemanticInterpretation, &type_spec_SpeechRecognitionSemanticInterpretation, bases.get());
    if (!state->type_SpeechRecognitionSemanticInterpretation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionSemanticInterpretation);

    state->type_SpeechRecognitionTopicConstraint = py::register_python_type(module.get(), type_name_SpeechRecognitionTopicConstraint, &type_spec_SpeechRecognitionTopicConstraint, bases.get());
    if (!state->type_SpeechRecognitionTopicConstraint)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionTopicConstraint);

    state->type_SpeechRecognitionVoiceCommandDefinitionConstraint = py::register_python_type(module.get(), type_name_SpeechRecognitionVoiceCommandDefinitionConstraint, &type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint, bases.get());
    if (!state->type_SpeechRecognitionVoiceCommandDefinitionConstraint)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognitionVoiceCommandDefinitionConstraint);

    state->type_SpeechRecognizer = py::register_python_type(module.get(), type_name_SpeechRecognizer, &type_spec_SpeechRecognizer, bases.get());
    if (!state->type_SpeechRecognizer)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognizer);

    state->type_SpeechRecognizerStateChangedEventArgs = py::register_python_type(module.get(), type_name_SpeechRecognizerStateChangedEventArgs, &type_spec_SpeechRecognizerStateChangedEventArgs, bases.get());
    if (!state->type_SpeechRecognizerStateChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognizerStateChangedEventArgs);

    state->type_SpeechRecognizerTimeouts = py::register_python_type(module.get(), type_name_SpeechRecognizerTimeouts, &type_spec_SpeechRecognizerTimeouts, bases.get());
    if (!state->type_SpeechRecognizerTimeouts)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognizerTimeouts);

    state->type_SpeechRecognizerUIOptions = py::register_python_type(module.get(), type_name_SpeechRecognizerUIOptions, &type_spec_SpeechRecognizerUIOptions, bases.get());
    if (!state->type_SpeechRecognizerUIOptions)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechRecognizerUIOptions);

    state->type_VoiceCommandManager = py::register_python_type(module.get(), type_name_VoiceCommandManager, &type_spec_VoiceCommandManager, nullptr);
    if (!state->type_VoiceCommandManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VoiceCommandManager);

    state->type_VoiceCommandSet = py::register_python_type(module.get(), type_name_VoiceCommandSet, &type_spec_VoiceCommandSet, bases.get());
    if (!state->type_VoiceCommandSet)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VoiceCommandSet);

    state->type_ISpeechRecognitionConstraint = py::register_python_type(module.get(), type_name_ISpeechRecognitionConstraint, &type_spec_ISpeechRecognitionConstraint, bases.get());
    if (!state->type_ISpeechRecognitionConstraint)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ISpeechRecognitionConstraint);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechContinuousRecognitionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionAudioProblem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionAudioProblem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionAudioProblem is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConfidence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionConfidence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConfidence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionConstraintProbability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionConstraintType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResultStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionResultStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResultStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionScenario;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognizerState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognizerState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechContinuousRecognitionCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechContinuousRecognitionResultGeneratedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechContinuousRecognitionSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionCompilationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionGrammarFileConstraint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionHypothesis;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionHypothesisGeneratedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionListConstraint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionQualityDegradingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionSemanticInterpretation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionTopicConstraint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognitionVoiceCommandDefinitionConstraint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognizer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognizer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognizerStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognizerTimeouts;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechRecognizerUIOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::VoiceCommandManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoiceCommandManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::VoiceCommandManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::VoiceCommandSet>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoiceCommandSet;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::VoiceCommandSet is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::SpeechRecognition;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::SpeechRecognition");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISpeechRecognitionConstraint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint is not registered");
        return nullptr;
    }

    return python_type;
}
