// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.7

#include "pybase.h"
#include "py.Windows.Devices.Usb.h"


namespace py::cpp::Windows::Devices::Usb
{
    struct module_state
    {
        PyObject* type_UsbControlRecipient;
        PyObject* type_UsbControlTransferType;
        PyObject* type_UsbEndpointType;
        PyObject* type_UsbReadOptions;
        PyObject* type_UsbTransferDirection;
        PyObject* type_UsbWriteOptions;
        PyTypeObject* type_UsbBulkInEndpointDescriptor;
        PyTypeObject* type_UsbBulkInPipe;
        PyTypeObject* type_UsbBulkOutEndpointDescriptor;
        PyTypeObject* type_UsbBulkOutPipe;
        PyTypeObject* type_UsbConfiguration;
        PyTypeObject* type_UsbConfigurationDescriptor;
        PyTypeObject* type_UsbControlRequestType;
        PyTypeObject* type_UsbDescriptor;
        PyTypeObject* type_UsbDevice;
        PyTypeObject* type_UsbDeviceClass;
        PyTypeObject* type_UsbDeviceClasses;
        PyTypeObject* type_UsbDeviceDescriptor;
        PyTypeObject* type_UsbEndpointDescriptor;
        PyTypeObject* type_UsbInterface;
        PyTypeObject* type_UsbInterfaceDescriptor;
        PyTypeObject* type_UsbInterfaceSetting;
        PyTypeObject* type_UsbInterruptInEndpointDescriptor;
        PyTypeObject* type_UsbInterruptInEventArgs;
        PyTypeObject* type_UsbInterruptInPipe;
        PyTypeObject* type_UsbInterruptOutEndpointDescriptor;
        PyTypeObject* type_UsbInterruptOutPipe;
        PyTypeObject* type_UsbSetupPacket;
    };

    static PyObject* register_UsbControlRecipient(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UsbControlRecipient)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UsbControlRecipient = type;
        Py_INCREF(state->type_UsbControlRecipient);


        Py_RETURN_NONE;
    }

    static PyObject* register_UsbControlTransferType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UsbControlTransferType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UsbControlTransferType = type;
        Py_INCREF(state->type_UsbControlTransferType);


        Py_RETURN_NONE;
    }

    static PyObject* register_UsbEndpointType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UsbEndpointType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UsbEndpointType = type;
        Py_INCREF(state->type_UsbEndpointType);


        Py_RETURN_NONE;
    }

    static PyObject* register_UsbReadOptions(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UsbReadOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UsbReadOptions = type;
        Py_INCREF(state->type_UsbReadOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_UsbTransferDirection(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UsbTransferDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UsbTransferDirection = type;
        Py_INCREF(state->type_UsbTransferDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_UsbWriteOptions(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UsbWriteOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UsbWriteOptions = type;
        Py_INCREF(state->type_UsbWriteOptions);


        Py_RETURN_NONE;
    }

    // ----- UsbBulkInEndpointDescriptor class --------------------
    constexpr const char* const type_name_UsbBulkInEndpointDescriptor = "UsbBulkInEndpointDescriptor";

    static PyObject* _new_UsbBulkInEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbBulkInEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkInEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkInEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkInEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbBulkInEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbBulkInEndpointDescriptor },
        { Py_tp_methods, _methods_UsbBulkInEndpointDescriptor },
        { Py_tp_getset, _getset_UsbBulkInEndpointDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbBulkInEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInEndpointDescriptor
    };

    // ----- UsbBulkInPipe class --------------------
    constexpr const char* const type_name_UsbBulkInPipe = "UsbBulkInPipe";

    static PyObject* _new_UsbBulkInPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbBulkInPipe);
        return nullptr;
    }

    static void _dealloc_UsbBulkInPipe(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"ClearStallAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_FlushBuffer(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"FlushBuffer", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                self->obj.FlushBuffer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"ReadOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkInPipe_put_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"ReadOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbReadOptions>(arg);

            self->obj.ReadOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_InputStream(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"InputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_MaxTransferSizeBytes(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkInPipe", L"MaxTransferSizeBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxTransferSizeBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbBulkInPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "flush_buffer", reinterpret_cast<PyCFunction>(UsbBulkInPipe_FlushBuffer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkInPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkInPipe[] = {
        { "read_options", reinterpret_cast<getter>(UsbBulkInPipe_get_ReadOptions), reinterpret_cast<setter>(UsbBulkInPipe_put_ReadOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbBulkInPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(UsbBulkInPipe_get_InputStream), nullptr, nullptr, nullptr },
        { "max_transfer_size_bytes", reinterpret_cast<getter>(UsbBulkInPipe_get_MaxTransferSizeBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkInPipe[] = 
    {
        { Py_tp_new, _new_UsbBulkInPipe },
        { Py_tp_dealloc, _dealloc_UsbBulkInPipe },
        { Py_tp_methods, _methods_UsbBulkInPipe },
        { Py_tp_getset, _getset_UsbBulkInPipe },
        { },
    };

    static PyType_Spec type_spec_UsbBulkInPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInPipe
    };

    // ----- UsbBulkOutEndpointDescriptor class --------------------
    constexpr const char* const type_name_UsbBulkOutEndpointDescriptor = "UsbBulkOutEndpointDescriptor";

    static PyObject* _new_UsbBulkOutEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbBulkOutEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkOutEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkOutEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkOutEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbBulkOutEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbBulkOutEndpointDescriptor },
        { Py_tp_methods, _methods_UsbBulkOutEndpointDescriptor },
        { Py_tp_getset, _getset_UsbBulkOutEndpointDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbBulkOutEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutEndpointDescriptor
    };

    // ----- UsbBulkOutPipe class --------------------
    constexpr const char* const type_name_UsbBulkOutPipe = "UsbBulkOutPipe";

    static PyObject* _new_UsbBulkOutPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbBulkOutPipe);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutPipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbBulkOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"ClearStallAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbBulkOutPipe", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbBulkOutPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkOutPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkOutPipe[] = {
        { "write_options", reinterpret_cast<getter>(UsbBulkOutPipe_get_WriteOptions), reinterpret_cast<setter>(UsbBulkOutPipe_put_WriteOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbBulkOutPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(UsbBulkOutPipe_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkOutPipe[] = 
    {
        { Py_tp_new, _new_UsbBulkOutPipe },
        { Py_tp_dealloc, _dealloc_UsbBulkOutPipe },
        { Py_tp_methods, _methods_UsbBulkOutPipe },
        { Py_tp_getset, _getset_UsbBulkOutPipe },
        { },
    };

    static PyType_Spec type_spec_UsbBulkOutPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutPipe
    };

    // ----- UsbConfiguration class --------------------
    constexpr const char* const type_name_UsbConfiguration = "UsbConfiguration";

    static PyObject* _new_UsbConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbConfiguration);
        return nullptr;
    }

    static void _dealloc_UsbConfiguration(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbConfiguration_get_ConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfiguration", L"ConfigurationDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConfigurationDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfiguration", L"Descriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_UsbInterfaces(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfiguration", L"UsbInterfaces"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsbInterfaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbConfiguration[] = {
        { "configuration_descriptor", reinterpret_cast<getter>(UsbConfiguration_get_ConfigurationDescriptor), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbConfiguration_get_Descriptors), nullptr, nullptr, nullptr },
        { "usb_interfaces", reinterpret_cast<getter>(UsbConfiguration_get_UsbInterfaces), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbConfiguration[] = 
    {
        { Py_tp_new, _new_UsbConfiguration },
        { Py_tp_dealloc, _dealloc_UsbConfiguration },
        { Py_tp_methods, _methods_UsbConfiguration },
        { Py_tp_getset, _getset_UsbConfiguration },
        { },
    };

    static PyType_Spec type_spec_UsbConfiguration =
    {
        "_winsdk_Windows_Devices_Usb.UsbConfiguration",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfiguration
    };

    // ----- UsbConfigurationDescriptor class --------------------
    constexpr const char* const type_name_UsbConfigurationDescriptor = "UsbConfigurationDescriptor";

    static PyObject* _new_UsbConfigurationDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbConfigurationDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbConfigurationDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"Parse", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"TryParse", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbConfigurationDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_ConfigurationValue(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"ConfigurationValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConfigurationValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_MaxPowerMilliamps(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"MaxPowerMilliamps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPowerMilliamps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_RemoteWakeup(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"RemoteWakeup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteWakeup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_SelfPowered(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbConfigurationDescriptor", L"SelfPowered"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelfPowered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbConfigurationDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfigurationDescriptor[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbConfigurationDescriptor_Parse), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbConfigurationDescriptor_TryParse), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbConfigurationDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbConfigurationDescriptor[] = {
        { "configuration_value", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_ConfigurationValue), nullptr, nullptr, nullptr },
        { "max_power_milliamps", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_MaxPowerMilliamps), nullptr, nullptr, nullptr },
        { "remote_wakeup", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_RemoteWakeup), nullptr, nullptr, nullptr },
        { "self_powered", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_SelfPowered), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbConfigurationDescriptor[] = 
    {
        { Py_tp_new, _new_UsbConfigurationDescriptor },
        { Py_tp_dealloc, _dealloc_UsbConfigurationDescriptor },
        { Py_tp_methods, _methods_UsbConfigurationDescriptor },
        { Py_tp_getset, _getset_UsbConfigurationDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbConfigurationDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbConfigurationDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfigurationDescriptor
    };

    // ----- UsbControlRequestType class --------------------
    constexpr const char* const type_name_UsbControlRequestType = "UsbControlRequestType";

    static PyObject* _new_UsbControlRequestType(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbControlRequestType instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbControlRequestType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbControlRequestType_get_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRecipient>(arg);

            self->obj.Recipient(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbTransferDirection>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"ControlTransferType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlTransferType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"ControlTransferType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlTransferType>(arg);

            self->obj.ControlTransferType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"AsByte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsByte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbControlRequestType", L"AsByte"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.AsByte(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbControlRequestType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbControlRequestType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbControlRequestType[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbControlRequestType), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbControlRequestType[] = {
        { "recipient", reinterpret_cast<getter>(UsbControlRequestType_get_Recipient), reinterpret_cast<setter>(UsbControlRequestType_put_Recipient), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(UsbControlRequestType_get_Direction), reinterpret_cast<setter>(UsbControlRequestType_put_Direction), nullptr, nullptr },
        { "control_transfer_type", reinterpret_cast<getter>(UsbControlRequestType_get_ControlTransferType), reinterpret_cast<setter>(UsbControlRequestType_put_ControlTransferType), nullptr, nullptr },
        { "as_byte", reinterpret_cast<getter>(UsbControlRequestType_get_AsByte), reinterpret_cast<setter>(UsbControlRequestType_put_AsByte), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbControlRequestType[] = 
    {
        { Py_tp_new, _new_UsbControlRequestType },
        { Py_tp_dealloc, _dealloc_UsbControlRequestType },
        { Py_tp_methods, _methods_UsbControlRequestType },
        { Py_tp_getset, _getset_UsbControlRequestType },
        { },
    };

    static PyType_Spec type_spec_UsbControlRequestType =
    {
        "_winsdk_Windows_Devices_Usb.UsbControlRequestType",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbControlRequestType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbControlRequestType
    };

    // ----- UsbDescriptor class --------------------
    constexpr const char* const type_name_UsbDescriptor = "UsbDescriptor";

    static PyObject* _new_UsbDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbDescriptor(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDescriptor_ReadDescriptorBuffer(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDescriptor", L"ReadDescriptorBuffer", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.ReadDescriptorBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_DescriptorType(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDescriptor", L"DescriptorType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DescriptorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_Length(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDescriptor", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDescriptor[] = {
        { "read_descriptor_buffer", reinterpret_cast<PyCFunction>(UsbDescriptor_ReadDescriptorBuffer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDescriptor[] = {
        { "descriptor_type", reinterpret_cast<getter>(UsbDescriptor_get_DescriptorType), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(UsbDescriptor_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDescriptor[] = 
    {
        { Py_tp_new, _new_UsbDescriptor },
        { Py_tp_dealloc, _dealloc_UsbDescriptor },
        { Py_tp_methods, _methods_UsbDescriptor },
        { Py_tp_getset, _getset_UsbDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDescriptor
    };

    // ----- UsbDevice class --------------------
    constexpr const char* const type_name_UsbDevice = "UsbDevice";

    static PyObject* _new_UsbDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbDevice);
        return nullptr;
    }

    static void _dealloc_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDevice_Close(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"Close", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"FromIdAsync", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceClassSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceClassSelector", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceClassSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceSelector", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceSelector", 2))
            {
                PyErr_SetString(PyExc_AttributeError, "method 2 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"GetDeviceSelector", 3))
            {
                PyErr_SetString(PyExc_AttributeError, "method 3 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlInTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlInTransferAsync", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlInTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlInTransferAsync", 2))
            {
                PyErr_SetString(PyExc_AttributeError, "method 2 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlInTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlOutTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlOutTransferAsync", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlOutTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbDevice", L"SendControlOutTransferAsync", 2))
            {
                PyErr_SetString(PyExc_AttributeError, "method 2 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlOutTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_Configuration(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDevice", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DefaultInterface(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDevice", L"DefaultInterface"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultInterface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDevice", L"DeviceDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(UsbDevice_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(UsbDevice_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_class_selector", reinterpret_cast<PyCFunction>(UsbDevice_GetDeviceClassSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(UsbDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "send_control_in_transfer_async", reinterpret_cast<PyCFunction>(UsbDevice_SendControlInTransferAsync), METH_VARARGS, nullptr },
        { "send_control_out_transfer_async", reinterpret_cast<PyCFunction>(UsbDevice_SendControlOutTransferAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_UsbDevice), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_UsbDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDevice[] = {
        { "configuration", reinterpret_cast<getter>(UsbDevice_get_Configuration), nullptr, nullptr, nullptr },
        { "default_interface", reinterpret_cast<getter>(UsbDevice_get_DefaultInterface), nullptr, nullptr, nullptr },
        { "device_descriptor", reinterpret_cast<getter>(UsbDevice_get_DeviceDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDevice[] = 
    {
        { Py_tp_new, _new_UsbDevice },
        { Py_tp_dealloc, _dealloc_UsbDevice },
        { Py_tp_methods, _methods_UsbDevice },
        { Py_tp_getset, _getset_UsbDevice },
        { },
    };

    static PyType_Spec type_spec_UsbDevice =
    {
        "_winsdk_Windows_Devices_Usb.UsbDevice",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDevice
    };

    // ----- UsbDeviceClass class --------------------
    constexpr const char* const type_name_UsbDeviceClass = "UsbDeviceClass";

    static PyObject* _new_UsbDeviceClass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbDeviceClass instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbDeviceClass(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDeviceClass_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"SubclassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"SubclassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.SubclassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ProtocolCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ProtocolCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.ProtocolCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ClassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClass", L"ClassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ClassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbDeviceClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClass[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceClass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceClass[] = {
        { "subclass_code", reinterpret_cast<getter>(UsbDeviceClass_get_SubclassCode), reinterpret_cast<setter>(UsbDeviceClass_put_SubclassCode), nullptr, nullptr },
        { "protocol_code", reinterpret_cast<getter>(UsbDeviceClass_get_ProtocolCode), reinterpret_cast<setter>(UsbDeviceClass_put_ProtocolCode), nullptr, nullptr },
        { "class_code", reinterpret_cast<getter>(UsbDeviceClass_get_ClassCode), reinterpret_cast<setter>(UsbDeviceClass_put_ClassCode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceClass[] = 
    {
        { Py_tp_new, _new_UsbDeviceClass },
        { Py_tp_dealloc, _dealloc_UsbDeviceClass },
        { Py_tp_methods, _methods_UsbDeviceClass },
        { Py_tp_getset, _getset_UsbDeviceClass },
        { },
    };

    static PyType_Spec type_spec_UsbDeviceClass =
    {
        "_winsdk_Windows_Devices_Usb.UsbDeviceClass",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClass
    };

    // ----- UsbDeviceClasses class --------------------
    constexpr const char* const type_name_UsbDeviceClasses = "UsbDeviceClasses";

    static PyObject* _new_UsbDeviceClasses(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbDeviceClasses);
        return nullptr;
    }

    static void _dealloc_UsbDeviceClasses(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDeviceClasses_get_ActiveSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"ActiveSync"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::ActiveSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_CdcControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"CdcControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::CdcControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_DeviceFirmwareUpdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"DeviceFirmwareUpdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::DeviceFirmwareUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Irda(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"Irda"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Irda());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Measurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"Measurement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Measurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PalmSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"PalmSync"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PalmSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PersonalHealthcare(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"PersonalHealthcare"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PersonalHealthcare());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Physical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"Physical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Physical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_VendorSpecific(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceClasses", L"VendorSpecific"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::VendorSpecific());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDeviceClasses(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClasses>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClasses[] = {
        { "get_active_sync", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_ActiveSync), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cdc_control", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_CdcControl), METH_NOARGS | METH_STATIC, nullptr },
        { "get_device_firmware_update", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_DeviceFirmwareUpdate), METH_NOARGS | METH_STATIC, nullptr },
        { "get_irda", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_Irda), METH_NOARGS | METH_STATIC, nullptr },
        { "get_measurement", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_Measurement), METH_NOARGS | METH_STATIC, nullptr },
        { "get_palm_sync", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_PalmSync), METH_NOARGS | METH_STATIC, nullptr },
        { "get_personal_healthcare", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_PersonalHealthcare), METH_NOARGS | METH_STATIC, nullptr },
        { "get_physical", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_Physical), METH_NOARGS | METH_STATIC, nullptr },
        { "get_vendor_specific", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_VendorSpecific), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceClasses), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceClasses[] = {
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceClasses[] = 
    {
        { Py_tp_new, _new_UsbDeviceClasses },
        { Py_tp_dealloc, _dealloc_UsbDeviceClasses },
        { Py_tp_methods, _methods_UsbDeviceClasses },
        { Py_tp_getset, _getset_UsbDeviceClasses },
        { },
    };

    static PyType_Spec type_spec_UsbDeviceClasses =
    {
        "_winsdk_Windows_Devices_Usb.UsbDeviceClasses",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClasses
    };

    // ----- UsbDeviceDescriptor class --------------------
    constexpr const char* const type_name_UsbDeviceDescriptor = "UsbDeviceDescriptor";

    static PyObject* _new_UsbDeviceDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbDeviceDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbDeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbDeviceDescriptor_get_BcdDeviceRevision(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"BcdDeviceRevision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BcdDeviceRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_BcdUsb(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"BcdUsb"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BcdUsb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_MaxPacketSize0(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"MaxPacketSize0"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize0());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_NumberOfConfigurations(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"NumberOfConfigurations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberOfConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_ProductId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_VendorId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbDeviceDescriptor", L"VendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDeviceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceDescriptor[] = {
        { "bcd_device_revision", reinterpret_cast<getter>(UsbDeviceDescriptor_get_BcdDeviceRevision), nullptr, nullptr, nullptr },
        { "bcd_usb", reinterpret_cast<getter>(UsbDeviceDescriptor_get_BcdUsb), nullptr, nullptr, nullptr },
        { "max_packet_size0", reinterpret_cast<getter>(UsbDeviceDescriptor_get_MaxPacketSize0), nullptr, nullptr, nullptr },
        { "number_of_configurations", reinterpret_cast<getter>(UsbDeviceDescriptor_get_NumberOfConfigurations), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(UsbDeviceDescriptor_get_ProductId), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(UsbDeviceDescriptor_get_VendorId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceDescriptor[] = 
    {
        { Py_tp_new, _new_UsbDeviceDescriptor },
        { Py_tp_dealloc, _dealloc_UsbDeviceDescriptor },
        { Py_tp_methods, _methods_UsbDeviceDescriptor },
        { Py_tp_getset, _getset_UsbDeviceDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbDeviceDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbDeviceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceDescriptor
    };

    // ----- UsbEndpointDescriptor class --------------------
    constexpr const char* const type_name_UsbEndpointDescriptor = "UsbEndpointDescriptor";

    static PyObject* _new_UsbEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbEndpointDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"Parse", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbEndpointDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"TryParse", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbEndpointDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbEndpointDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsBulkInEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsBulkInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsBulkOutEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsBulkOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsInterruptInEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsInterruptInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"AsInterruptOutEndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AsInterruptOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_Direction(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointType(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbEndpointDescriptor", L"EndpointType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbEndpointDescriptor[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbEndpointDescriptor_Parse), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbEndpointDescriptor_TryParse), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbEndpointDescriptor[] = {
        { "as_bulk_in_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_bulk_out_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_interrupt_in_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_interrupt_out_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor), nullptr, nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(UsbEndpointDescriptor_get_Direction), nullptr, nullptr, nullptr },
        { "endpoint_number", reinterpret_cast<getter>(UsbEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "endpoint_type", reinterpret_cast<getter>(UsbEndpointDescriptor_get_EndpointType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbEndpointDescriptor },
        { Py_tp_methods, _methods_UsbEndpointDescriptor },
        { Py_tp_getset, _getset_UsbEndpointDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbEndpointDescriptor
    };

    // ----- UsbInterface class --------------------
    constexpr const char* const type_name_UsbInterface = "UsbInterface";

    static PyObject* _new_UsbInterface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterface);
        return nullptr;
    }

    static void _dealloc_UsbInterface(py::wrapper::Windows::Devices::Usb::UsbInterface* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterface_get_BulkInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"BulkInPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_BulkOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"BulkOutPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"Descriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterfaceNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceSettings(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterfaceSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterruptInPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterface", L"InterruptOutPipes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterface[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterface[] = {
        { "bulk_in_pipes", reinterpret_cast<getter>(UsbInterface_get_BulkInPipes), nullptr, nullptr, nullptr },
        { "bulk_out_pipes", reinterpret_cast<getter>(UsbInterface_get_BulkOutPipes), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbInterface_get_Descriptors), nullptr, nullptr, nullptr },
        { "interface_number", reinterpret_cast<getter>(UsbInterface_get_InterfaceNumber), nullptr, nullptr, nullptr },
        { "interface_settings", reinterpret_cast<getter>(UsbInterface_get_InterfaceSettings), nullptr, nullptr, nullptr },
        { "interrupt_in_pipes", reinterpret_cast<getter>(UsbInterface_get_InterruptInPipes), nullptr, nullptr, nullptr },
        { "interrupt_out_pipes", reinterpret_cast<getter>(UsbInterface_get_InterruptOutPipes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterface[] = 
    {
        { Py_tp_new, _new_UsbInterface },
        { Py_tp_dealloc, _dealloc_UsbInterface },
        { Py_tp_methods, _methods_UsbInterface },
        { Py_tp_getset, _getset_UsbInterface },
        { },
    };

    static PyType_Spec type_spec_UsbInterface =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterface",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterface
    };

    // ----- UsbInterfaceDescriptor class --------------------
    constexpr const char* const type_name_UsbInterfaceDescriptor = "UsbInterfaceDescriptor";

    static PyObject* _new_UsbInterfaceDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterfaceDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterfaceDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"Parse", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"TryParse", 1))
            {
                PyErr_SetString(PyExc_AttributeError, "method 1 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbInterfaceDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_AlternateSettingNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"AlternateSettingNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlternateSettingNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"ClassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"InterfaceNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"ProtocolCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceDescriptor", L"SubclassCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterfaceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceDescriptor[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbInterfaceDescriptor_Parse), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbInterfaceDescriptor_TryParse), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterfaceDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterfaceDescriptor[] = {
        { "alternate_setting_number", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_AlternateSettingNumber), nullptr, nullptr, nullptr },
        { "class_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_ClassCode), nullptr, nullptr, nullptr },
        { "interface_number", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_InterfaceNumber), nullptr, nullptr, nullptr },
        { "protocol_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_ProtocolCode), nullptr, nullptr, nullptr },
        { "subclass_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_SubclassCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterfaceDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterfaceDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterfaceDescriptor },
        { Py_tp_methods, _methods_UsbInterfaceDescriptor },
        { Py_tp_getset, _getset_UsbInterfaceDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbInterfaceDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterfaceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceDescriptor
    };

    // ----- UsbInterfaceSetting class --------------------
    constexpr const char* const type_name_UsbInterfaceSetting = "UsbInterfaceSetting";

    static PyObject* _new_UsbInterfaceSetting(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterfaceSetting);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceSetting(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterfaceSetting_SelectSettingAsync(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"SelectSettingAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SelectSettingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"BulkInEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"BulkOutEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BulkOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"Descriptors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"InterfaceDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterfaceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"InterruptInEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"InterruptOutEndpoints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Selected(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterfaceSetting", L"Selected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterfaceSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceSetting>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceSetting[] = {
        { "select_setting_async", reinterpret_cast<PyCFunction>(UsbInterfaceSetting_SelectSettingAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterfaceSetting), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterfaceSetting[] = {
        { "bulk_in_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_BulkInEndpoints), nullptr, nullptr, nullptr },
        { "bulk_out_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_BulkOutEndpoints), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbInterfaceSetting_get_Descriptors), nullptr, nullptr, nullptr },
        { "interface_descriptor", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterfaceDescriptor), nullptr, nullptr, nullptr },
        { "interrupt_in_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterruptInEndpoints), nullptr, nullptr, nullptr },
        { "interrupt_out_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterruptOutEndpoints), nullptr, nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(UsbInterfaceSetting_get_Selected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterfaceSetting[] = 
    {
        { Py_tp_new, _new_UsbInterfaceSetting },
        { Py_tp_dealloc, _dealloc_UsbInterfaceSetting },
        { Py_tp_methods, _methods_UsbInterfaceSetting },
        { Py_tp_getset, _getset_UsbInterfaceSetting },
        { },
    };

    static PyType_Spec type_spec_UsbInterfaceSetting =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterfaceSetting",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceSetting
    };

    // ----- UsbInterruptInEndpointDescriptor class --------------------
    constexpr const char* const type_name_UsbInterruptInEndpointDescriptor = "UsbInterruptInEndpointDescriptor";

    static PyObject* _new_UsbInterruptInEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterruptInEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_Interval), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterruptInEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterruptInEndpointDescriptor },
        { Py_tp_methods, _methods_UsbInterruptInEndpointDescriptor },
        { Py_tp_getset, _getset_UsbInterruptInEndpointDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptInEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEndpointDescriptor
    };

    // ----- UsbInterruptInEventArgs class --------------------
    constexpr const char* const type_name_UsbInterruptInEventArgs = "UsbInterruptInEventArgs";

    static PyObject* _new_UsbInterruptInEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterruptInEventArgs);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEventArgs(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptInEventArgs_get_InterruptData(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInEventArgs", L"InterruptData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInEventArgs[] = {
        { "interrupt_data", reinterpret_cast<getter>(UsbInterruptInEventArgs_get_InterruptData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInEventArgs[] = 
    {
        { Py_tp_new, _new_UsbInterruptInEventArgs },
        { Py_tp_dealloc, _dealloc_UsbInterruptInEventArgs },
        { Py_tp_methods, _methods_UsbInterruptInEventArgs },
        { Py_tp_getset, _getset_UsbInterruptInEventArgs },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptInEventArgs =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptInEventArgs",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEventArgs
    };

    // ----- UsbInterruptInPipe class --------------------
    constexpr const char* const type_name_UsbInterruptInPipe = "UsbInterruptInPipe";

    static PyObject* _new_UsbInterruptInPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterruptInPipe);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"ClearStallAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_add_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Usb::UsbInterruptInPipe, winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_remove_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Usb.UsbInterruptInPipe", L"DataReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_remove_DataReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInPipe[] = {
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbInterruptInPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInPipe[] = 
    {
        { Py_tp_new, _new_UsbInterruptInPipe },
        { Py_tp_dealloc, _dealloc_UsbInterruptInPipe },
        { Py_tp_methods, _methods_UsbInterruptInPipe },
        { Py_tp_getset, _getset_UsbInterruptInPipe },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptInPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInPipe
    };

    // ----- UsbInterruptOutEndpointDescriptor class --------------------
    constexpr const char* const type_name_UsbInterruptOutEndpointDescriptor = "UsbInterruptOutEndpointDescriptor";

    static PyObject* _new_UsbInterruptOutEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterruptOutEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"EndpointNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"Interval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"MaxPacketSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor", L"Pipe"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptOutEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptOutEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_Interval), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptOutEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterruptOutEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterruptOutEndpointDescriptor },
        { Py_tp_methods, _methods_UsbInterruptOutEndpointDescriptor },
        { Py_tp_getset, _getset_UsbInterruptOutEndpointDescriptor },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptOutEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutEndpointDescriptor
    };

    // ----- UsbInterruptOutPipe class --------------------
    constexpr const char* const type_name_UsbInterruptOutPipe = "UsbInterruptOutPipe";

    static PyObject* _new_UsbInterruptOutPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UsbInterruptOutPipe);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbInterruptOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"ClearStallAsync", 0))
            {
                PyErr_SetString(PyExc_AttributeError, "method 0 args is not available in this version of Windows");
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbInterruptOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"WriteOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"EndpointDescriptor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbInterruptOutPipe", L"OutputStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbInterruptOutPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptOutPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptOutPipe[] = {
        { "write_options", reinterpret_cast<getter>(UsbInterruptOutPipe_get_WriteOptions), reinterpret_cast<setter>(UsbInterruptOutPipe_put_WriteOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbInterruptOutPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(UsbInterruptOutPipe_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptOutPipe[] = 
    {
        { Py_tp_new, _new_UsbInterruptOutPipe },
        { Py_tp_dealloc, _dealloc_UsbInterruptOutPipe },
        { Py_tp_methods, _methods_UsbInterruptOutPipe },
        { Py_tp_getset, _getset_UsbInterruptOutPipe },
        { },
    };

    static PyType_Spec type_spec_UsbInterruptOutPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutPipe
    };

    // ----- UsbSetupPacket class --------------------
    constexpr const char* const type_name_UsbSetupPacket = "UsbSetupPacket";

    static PyObject* _new_UsbSetupPacket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Usb::UsbSetupPacket instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbSetupPacket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbSetupPacket(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UsbSetupPacket_get_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"RequestType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"RequestType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRequestType>(arg);

            self->obj.RequestType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.Request(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Index"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Usb.UsbSetupPacket", L"Index"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Index(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbSetupPacket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbSetupPacket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbSetupPacket[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbSetupPacket), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbSetupPacket[] = {
        { "value", reinterpret_cast<getter>(UsbSetupPacket_get_Value), reinterpret_cast<setter>(UsbSetupPacket_put_Value), nullptr, nullptr },
        { "request_type", reinterpret_cast<getter>(UsbSetupPacket_get_RequestType), reinterpret_cast<setter>(UsbSetupPacket_put_RequestType), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(UsbSetupPacket_get_Request), reinterpret_cast<setter>(UsbSetupPacket_put_Request), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(UsbSetupPacket_get_Length), reinterpret_cast<setter>(UsbSetupPacket_put_Length), nullptr, nullptr },
        { "index", reinterpret_cast<getter>(UsbSetupPacket_get_Index), reinterpret_cast<setter>(UsbSetupPacket_put_Index), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbSetupPacket[] = 
    {
        { Py_tp_new, _new_UsbSetupPacket },
        { Py_tp_dealloc, _dealloc_UsbSetupPacket },
        { Py_tp_methods, _methods_UsbSetupPacket },
        { Py_tp_getset, _getset_UsbSetupPacket },
        { },
    };

    static PyType_Spec type_spec_UsbSetupPacket =
    {
        "_winsdk_Windows_Devices_Usb.UsbSetupPacket",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbSetupPacket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbSetupPacket
    };

    // ----- Windows.Devices.Usb Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Usb");

    static PyMethodDef module_methods[] = {
        {"_register_UsbControlRecipient", register_UsbControlRecipient, METH_O, "registers type"},
        {"_register_UsbControlTransferType", register_UsbControlTransferType, METH_O, "registers type"},
        {"_register_UsbEndpointType", register_UsbEndpointType, METH_O, "registers type"},
        {"_register_UsbReadOptions", register_UsbReadOptions, METH_O, "registers type"},
        {"_register_UsbTransferDirection", register_UsbTransferDirection, METH_O, "registers type"},
        {"_register_UsbWriteOptions", register_UsbWriteOptions, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_UsbControlRecipient);
        Py_VISIT(state->type_UsbControlTransferType);
        Py_VISIT(state->type_UsbEndpointType);
        Py_VISIT(state->type_UsbReadOptions);
        Py_VISIT(state->type_UsbTransferDirection);
        Py_VISIT(state->type_UsbWriteOptions);
        Py_VISIT(state->type_UsbBulkInEndpointDescriptor);
        Py_VISIT(state->type_UsbBulkInPipe);
        Py_VISIT(state->type_UsbBulkOutEndpointDescriptor);
        Py_VISIT(state->type_UsbBulkOutPipe);
        Py_VISIT(state->type_UsbConfiguration);
        Py_VISIT(state->type_UsbConfigurationDescriptor);
        Py_VISIT(state->type_UsbControlRequestType);
        Py_VISIT(state->type_UsbDescriptor);
        Py_VISIT(state->type_UsbDevice);
        Py_VISIT(state->type_UsbDeviceClass);
        Py_VISIT(state->type_UsbDeviceClasses);
        Py_VISIT(state->type_UsbDeviceDescriptor);
        Py_VISIT(state->type_UsbEndpointDescriptor);
        Py_VISIT(state->type_UsbInterface);
        Py_VISIT(state->type_UsbInterfaceDescriptor);
        Py_VISIT(state->type_UsbInterfaceSetting);
        Py_VISIT(state->type_UsbInterruptInEndpointDescriptor);
        Py_VISIT(state->type_UsbInterruptInEventArgs);
        Py_VISIT(state->type_UsbInterruptInPipe);
        Py_VISIT(state->type_UsbInterruptOutEndpointDescriptor);
        Py_VISIT(state->type_UsbInterruptOutPipe);
        Py_VISIT(state->type_UsbSetupPacket);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_UsbControlRecipient);
        Py_CLEAR(state->type_UsbControlTransferType);
        Py_CLEAR(state->type_UsbEndpointType);
        Py_CLEAR(state->type_UsbReadOptions);
        Py_CLEAR(state->type_UsbTransferDirection);
        Py_CLEAR(state->type_UsbWriteOptions);
        Py_CLEAR(state->type_UsbBulkInEndpointDescriptor);
        Py_CLEAR(state->type_UsbBulkInPipe);
        Py_CLEAR(state->type_UsbBulkOutEndpointDescriptor);
        Py_CLEAR(state->type_UsbBulkOutPipe);
        Py_CLEAR(state->type_UsbConfiguration);
        Py_CLEAR(state->type_UsbConfigurationDescriptor);
        Py_CLEAR(state->type_UsbControlRequestType);
        Py_CLEAR(state->type_UsbDescriptor);
        Py_CLEAR(state->type_UsbDevice);
        Py_CLEAR(state->type_UsbDeviceClass);
        Py_CLEAR(state->type_UsbDeviceClasses);
        Py_CLEAR(state->type_UsbDeviceDescriptor);
        Py_CLEAR(state->type_UsbEndpointDescriptor);
        Py_CLEAR(state->type_UsbInterface);
        Py_CLEAR(state->type_UsbInterfaceDescriptor);
        Py_CLEAR(state->type_UsbInterfaceSetting);
        Py_CLEAR(state->type_UsbInterruptInEndpointDescriptor);
        Py_CLEAR(state->type_UsbInterruptInEventArgs);
        Py_CLEAR(state->type_UsbInterruptInPipe);
        Py_CLEAR(state->type_UsbInterruptOutEndpointDescriptor);
        Py_CLEAR(state->type_UsbInterruptOutPipe);
        Py_CLEAR(state->type_UsbSetupPacket);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Usb",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Usb

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Usb(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Usb;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_UsbBulkInEndpointDescriptor = py::register_python_type(module.get(), type_name_UsbBulkInEndpointDescriptor, &type_spec_UsbBulkInEndpointDescriptor, bases.get());
    if (!state->type_UsbBulkInEndpointDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbBulkInEndpointDescriptor);

    state->type_UsbBulkInPipe = py::register_python_type(module.get(), type_name_UsbBulkInPipe, &type_spec_UsbBulkInPipe, bases.get());
    if (!state->type_UsbBulkInPipe)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbBulkInPipe);

    state->type_UsbBulkOutEndpointDescriptor = py::register_python_type(module.get(), type_name_UsbBulkOutEndpointDescriptor, &type_spec_UsbBulkOutEndpointDescriptor, bases.get());
    if (!state->type_UsbBulkOutEndpointDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbBulkOutEndpointDescriptor);

    state->type_UsbBulkOutPipe = py::register_python_type(module.get(), type_name_UsbBulkOutPipe, &type_spec_UsbBulkOutPipe, bases.get());
    if (!state->type_UsbBulkOutPipe)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbBulkOutPipe);

    state->type_UsbConfiguration = py::register_python_type(module.get(), type_name_UsbConfiguration, &type_spec_UsbConfiguration, bases.get());
    if (!state->type_UsbConfiguration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbConfiguration);

    state->type_UsbConfigurationDescriptor = py::register_python_type(module.get(), type_name_UsbConfigurationDescriptor, &type_spec_UsbConfigurationDescriptor, bases.get());
    if (!state->type_UsbConfigurationDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbConfigurationDescriptor);

    state->type_UsbControlRequestType = py::register_python_type(module.get(), type_name_UsbControlRequestType, &type_spec_UsbControlRequestType, bases.get());
    if (!state->type_UsbControlRequestType)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbControlRequestType);

    state->type_UsbDescriptor = py::register_python_type(module.get(), type_name_UsbDescriptor, &type_spec_UsbDescriptor, bases.get());
    if (!state->type_UsbDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbDescriptor);

    state->type_UsbDevice = py::register_python_type(module.get(), type_name_UsbDevice, &type_spec_UsbDevice, bases.get());
    if (!state->type_UsbDevice)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbDevice);

    state->type_UsbDeviceClass = py::register_python_type(module.get(), type_name_UsbDeviceClass, &type_spec_UsbDeviceClass, bases.get());
    if (!state->type_UsbDeviceClass)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbDeviceClass);

    state->type_UsbDeviceClasses = py::register_python_type(module.get(), type_name_UsbDeviceClasses, &type_spec_UsbDeviceClasses, bases.get());
    if (!state->type_UsbDeviceClasses)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbDeviceClasses);

    state->type_UsbDeviceDescriptor = py::register_python_type(module.get(), type_name_UsbDeviceDescriptor, &type_spec_UsbDeviceDescriptor, bases.get());
    if (!state->type_UsbDeviceDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbDeviceDescriptor);

    state->type_UsbEndpointDescriptor = py::register_python_type(module.get(), type_name_UsbEndpointDescriptor, &type_spec_UsbEndpointDescriptor, bases.get());
    if (!state->type_UsbEndpointDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbEndpointDescriptor);

    state->type_UsbInterface = py::register_python_type(module.get(), type_name_UsbInterface, &type_spec_UsbInterface, bases.get());
    if (!state->type_UsbInterface)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterface);

    state->type_UsbInterfaceDescriptor = py::register_python_type(module.get(), type_name_UsbInterfaceDescriptor, &type_spec_UsbInterfaceDescriptor, bases.get());
    if (!state->type_UsbInterfaceDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterfaceDescriptor);

    state->type_UsbInterfaceSetting = py::register_python_type(module.get(), type_name_UsbInterfaceSetting, &type_spec_UsbInterfaceSetting, bases.get());
    if (!state->type_UsbInterfaceSetting)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterfaceSetting);

    state->type_UsbInterruptInEndpointDescriptor = py::register_python_type(module.get(), type_name_UsbInterruptInEndpointDescriptor, &type_spec_UsbInterruptInEndpointDescriptor, bases.get());
    if (!state->type_UsbInterruptInEndpointDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterruptInEndpointDescriptor);

    state->type_UsbInterruptInEventArgs = py::register_python_type(module.get(), type_name_UsbInterruptInEventArgs, &type_spec_UsbInterruptInEventArgs, bases.get());
    if (!state->type_UsbInterruptInEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterruptInEventArgs);

    state->type_UsbInterruptInPipe = py::register_python_type(module.get(), type_name_UsbInterruptInPipe, &type_spec_UsbInterruptInPipe, bases.get());
    if (!state->type_UsbInterruptInPipe)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterruptInPipe);

    state->type_UsbInterruptOutEndpointDescriptor = py::register_python_type(module.get(), type_name_UsbInterruptOutEndpointDescriptor, &type_spec_UsbInterruptOutEndpointDescriptor, bases.get());
    if (!state->type_UsbInterruptOutEndpointDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterruptOutEndpointDescriptor);

    state->type_UsbInterruptOutPipe = py::register_python_type(module.get(), type_name_UsbInterruptOutPipe, &type_spec_UsbInterruptOutPipe, bases.get());
    if (!state->type_UsbInterruptOutPipe)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbInterruptOutPipe);

    state->type_UsbSetupPacket = py::register_python_type(module.get(), type_name_UsbSetupPacket, &type_spec_UsbSetupPacket, bases.get());
    if (!state->type_UsbSetupPacket)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UsbSetupPacket);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Usb::UsbControlRecipient>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbControlRecipient;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbControlRecipient is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Usb::UsbControlTransferType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbControlTransferType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbControlTransferType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Usb::UsbEndpointType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbEndpointType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbEndpointType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Usb::UsbReadOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbReadOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbReadOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Usb::UsbTransferDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbTransferDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbTransferDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Usb::UsbWriteOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbWriteOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbWriteOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbBulkInEndpointDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbBulkInPipe;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbBulkInPipe is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbBulkOutEndpointDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbBulkOutPipe;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbBulkOutPipe is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbConfigurationDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbConfigurationDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbControlRequestType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbControlRequestType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbControlRequestType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbDeviceClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbDeviceClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbDeviceClasses;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbDeviceClasses is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbDeviceDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbDeviceDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbEndpointDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbEndpointDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterface>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterface;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterface is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterfaceDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterfaceDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterfaceSetting;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterfaceSetting is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterruptInEndpointDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterruptInEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterruptInEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterruptInPipe;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterruptInPipe is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterruptOutEndpointDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbInterruptOutPipe;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbInterruptOutPipe is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbSetupPacket>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Usb;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Usb");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UsbSetupPacket;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Usb::UsbSetupPacket is not registered");
        return nullptr;
    }

    return python_type;
}
