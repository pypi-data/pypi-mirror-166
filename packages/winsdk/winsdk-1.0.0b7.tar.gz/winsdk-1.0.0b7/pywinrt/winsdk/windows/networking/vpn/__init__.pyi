# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.7

import enum
import datetime
import sys
import types
import typing

import winsdk._winrt as _winrt
import winsdk.windows.applicationmodel.activation
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.networking
import winsdk.windows.networking.sockets
import winsdk.windows.security.credentials
import winsdk.windows.security.cryptography.certificates
import winsdk.windows.storage.streams
import winsdk.windows.system

class VpnAppIdType(enum.IntEnum):
    PACKAGE_FAMILY_NAME = 0
    FULLY_QUALIFIED_BINARY_NAME = 1
    FILE_PATH = 2

class VpnAuthenticationMethod(enum.IntEnum):
    MSCHAPV2 = 0
    EAP = 1
    CERTIFICATE = 2
    PRESHARED_KEY = 3

class VpnChannelActivityEventType(enum.IntEnum):
    IDLE = 0
    ACTIVE = 1

class VpnChannelRequestCredentialsOptions(enum.IntFlag):
    NONE = 0
    RETRYING = 0x1
    USE_FOR_SINGLE_SIGN_IN = 0x2

class VpnCredentialType(enum.IntEnum):
    USERNAME_PASSWORD = 0
    USERNAME_OTP_PIN = 1
    USERNAME_PASSWORD_AND_PIN = 2
    USERNAME_PASSWORD_CHANGE = 3
    SMART_CARD = 4
    PROTECTED_CERTIFICATE = 5
    UN_PROTECTED_CERTIFICATE = 6

class VpnDataPathType(enum.IntEnum):
    SEND = 0
    RECEIVE = 1

class VpnDomainNameType(enum.IntEnum):
    SUFFIX = 0
    FULLY_QUALIFIED = 1
    RESERVED = 65535

class VpnIPProtocol(enum.IntEnum):
    NONE = 0
    TCP = 6
    UDP = 17
    ICMP = 1
    IPV6_ICMP = 58
    IGMP = 2
    PGM = 113

class VpnManagementConnectionStatus(enum.IntEnum):
    DISCONNECTED = 0
    DISCONNECTING = 1
    CONNECTED = 2
    CONNECTING = 3

class VpnManagementErrorStatus(enum.IntEnum):
    OK = 0
    OTHER = 1
    INVALID_XML_SYNTAX = 2
    PROFILE_NAME_TOO_LONG = 3
    PROFILE_INVALID_APP_ID = 4
    ACCESS_DENIED = 5
    CANNOT_FIND_PROFILE = 6
    ALREADY_DISCONNECTING = 7
    ALREADY_CONNECTED = 8
    GENERAL_AUTHENTICATION_FAILURE = 9
    EAP_FAILURE = 10
    SMART_CARD_FAILURE = 11
    CERTIFICATE_FAILURE = 12
    SERVER_CONFIGURATION = 13
    NO_CONNECTION = 14
    SERVER_CONNECTION = 15
    USER_NAME_PASSWORD = 16
    DNS_NOT_RESOLVABLE = 17
    INVALID_I_P = 18

class VpnNativeProtocolType(enum.IntEnum):
    PPTP = 0
    L2TP = 1
    IPSEC_IKEV2 = 2

class VpnPacketBufferStatus(enum.IntEnum):
    OK = 0
    INVALID_BUFFER_SIZE = 1

class VpnRoutingPolicyType(enum.IntEnum):
    SPLIT_ROUTING = 0
    FORCE_ALL_TRAFFIC_OVER_VPN = 1

Self = typing.TypeVar('Self')

class VpnAppId(_winrt.Object):
    value: str
    type: VpnAppIdType
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnAppId: ...
    def __new__(cls: typing.Type[VpnAppId], type: VpnAppIdType, value: str) -> VpnAppId:...

class VpnChannel(_winrt.Object):
    plug_in_context: typing.Optional[_winrt.Object]
    configuration: typing.Optional[VpnChannelConfiguration]
    id: _winrt.UInt32
    system_health: typing.Optional[VpnSystemHealth]
    current_request_transport_context: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnChannel: ...
    def activate_foreground(self, package_relative_app_id: str, shared_context: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> typing.Optional[winsdk.windows.foundation.collections.ValueSet]: ...
    def add_and_associate_transport(self, transport: typing.Optional[_winrt.Object], context: typing.Optional[_winrt.Object]) -> None: ...
    def append_vpn_receive_packet_buffer(self, decapsulated_packet_buffer: typing.Optional[VpnPacketBuffer]) -> None: ...
    def append_vpn_send_packet_buffer(self, encapsulated_packet_buffer: typing.Optional[VpnPacketBuffer]) -> None: ...
    def associate_transport(self, main_outer_tunnel_transport: typing.Optional[_winrt.Object], optional_outer_tunnel_transport: typing.Optional[_winrt.Object]) -> None: ...
    def flush_vpn_receive_packet_buffers(self) -> None: ...
    def flush_vpn_send_packet_buffers(self) -> None: ...
    def get_slot_type_for_transport_context(self, context: typing.Optional[_winrt.Object]) -> winsdk.windows.networking.sockets.ControlChannelTriggerStatus: ...
    def get_vpn_receive_packet_buffer(self) -> typing.Optional[VpnPacketBuffer]: ...
    def get_vpn_send_packet_buffer(self) -> typing.Optional[VpnPacketBuffer]: ...
    def log_diagnostic_message(self, message: str) -> None: ...
    @staticmethod
    def process_event_async(third_party_plug_in: typing.Optional[_winrt.Object], event: typing.Optional[_winrt.Object]) -> None: ...
    def replace_and_associate_transport(self, transport: typing.Optional[_winrt.Object], context: typing.Optional[_winrt.Object]) -> None: ...
    def request_credentials(self, cred_type: VpnCredentialType, is_retry: _winrt.Boolean, is_single_sign_on_credential: _winrt.Boolean, certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]) -> typing.Optional[VpnPickedCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType) -> winsdk.windows.foundation.IAsyncOperation[VpnCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, cred_options: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[VpnCredential]: ...
    @typing.overload
    def request_credentials_async(self, cred_type: VpnCredentialType, cred_options: _winrt.UInt32, certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]) -> winsdk.windows.foundation.IAsyncOperation[VpnCredential]: ...
    def request_custom_prompt(self, custom_prompt: winsdk.windows.foundation.collections.IVectorView[IVpnCustomPrompt]) -> None: ...
    def request_custom_prompt_async(self, custom_prompt_element: winsdk.windows.foundation.collections.IVectorView[IVpnCustomPromptElement]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def request_vpn_packet_buffer(self, type: VpnDataPathType) -> typing.Optional[VpnPacketBuffer]: ...
    def set_allowed_ssl_tls_versions(self, tunnel_transport: typing.Optional[_winrt.Object], use_tls12: _winrt.Boolean) -> None: ...
    def set_error_message(self, message: str) -> None: ...
    def start(self, assigned_client_i_pv4list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], assigned_client_i_pv6list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], route_scope: typing.Optional[VpnRouteAssignment], namespace_scope: typing.Optional[VpnNamespaceAssignment], mtu_size: _winrt.UInt32, max_frame_size: _winrt.UInt32, optimize_for_low_cost_network: _winrt.Boolean, main_outer_tunnel_transport: typing.Optional[_winrt.Object], optional_outer_tunnel_transport: typing.Optional[_winrt.Object]) -> None: ...
    def start_existing_transports(self, assigned_client_i_pv4list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], assigned_client_i_pv6list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_domain_name: typing.Optional[VpnDomainNameAssignment], mtu_size: _winrt.UInt32, max_frame_size: _winrt.UInt32, reserved: _winrt.Boolean) -> None: ...
    def start_reconnecting_transport(self, transport: typing.Optional[_winrt.Object], context: typing.Optional[_winrt.Object]) -> None: ...
    def start_with_main_transport(self, assigned_client_i_pv4list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], assigned_client_i_pv6list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_domain_name: typing.Optional[VpnDomainNameAssignment], mtu_size: _winrt.UInt32, max_frame_size: _winrt.UInt32, reserved: _winrt.Boolean, main_outer_tunnel_transport: typing.Optional[_winrt.Object]) -> None: ...
    @typing.overload
    def start_with_traffic_filter(self, assigned_client_ipv4_addresses: typing.Iterable[winsdk.windows.networking.HostName], assigned_client_ipv6_addresses: typing.Iterable[winsdk.windows.networking.HostName], vpninterface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_namespace: typing.Optional[VpnDomainNameAssignment], mtu_size: _winrt.UInt32, max_frame_size: _winrt.UInt32, reserved: _winrt.Boolean, transports: typing.Iterable[_winrt.Object], assigned_traffic_filters: typing.Optional[VpnTrafficFilterAssignment]) -> None: ...
    @typing.overload
    def start_with_traffic_filter(self, assigned_client_ipv4_list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], assigned_client_ipv6_list: winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName], vpn_interface_id: typing.Optional[VpnInterfaceId], assigned_routes: typing.Optional[VpnRouteAssignment], assigned_namespace: typing.Optional[VpnDomainNameAssignment], mtu_size: _winrt.UInt32, max_frame_size: _winrt.UInt32, reserved: _winrt.Boolean, main_outer_tunnel_transport: typing.Optional[_winrt.Object], optional_outer_tunnel_transport: typing.Optional[_winrt.Object], assigned_traffic_filters: typing.Optional[VpnTrafficFilterAssignment]) -> None: ...
    def stop(self) -> None: ...
    def terminate_connection(self, message: str) -> None: ...
    def add_activity_change(self, handler: winsdk.windows.foundation.TypedEventHandler[VpnChannel, VpnChannelActivityEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_activity_change(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_activity_state_change(self, handler: winsdk.windows.foundation.TypedEventHandler[VpnChannel, VpnChannelActivityStateChangedArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_activity_state_change(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class VpnChannelActivityEventArgs(_winrt.Object):
    type: VpnChannelActivityEventType
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnChannelActivityEventArgs: ...

class VpnChannelActivityStateChangedArgs(_winrt.Object):
    activity_state: VpnChannelActivityEventType
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnChannelActivityStateChangedArgs: ...

class VpnChannelConfiguration(_winrt.Object):
    custom_field: str
    server_host_name_list: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.HostName]]
    server_service_name: str
    server_uris: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnChannelConfiguration: ...

class VpnCredential(_winrt.Object):
    additional_pin: str
    certificate_credential: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    old_password_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    passkey_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCredential: ...

class VpnCustomCheckBox(_winrt.Object):
    initial_check_state: _winrt.Boolean
    checked: _winrt.Boolean
    label: str
    compulsory: _winrt.Boolean
    bordered: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomCheckBox: ...
    def __new__(cls: typing.Type[VpnCustomCheckBox]) -> VpnCustomCheckBox:...

class VpnCustomComboBox(_winrt.Object):
    options_text: typing.Optional[winsdk.windows.foundation.collections.IVectorView[str]]
    selected: _winrt.UInt32
    label: str
    compulsory: _winrt.Boolean
    bordered: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomComboBox: ...
    def __new__(cls: typing.Type[VpnCustomComboBox]) -> VpnCustomComboBox:...

class VpnCustomEditBox(_winrt.Object):
    no_echo: _winrt.Boolean
    default_text: str
    text: str
    label: str
    compulsory: _winrt.Boolean
    bordered: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomEditBox: ...
    def __new__(cls: typing.Type[VpnCustomEditBox]) -> VpnCustomEditBox:...

class VpnCustomErrorBox(_winrt.Object):
    label: str
    compulsory: _winrt.Boolean
    bordered: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomErrorBox: ...
    def __new__(cls: typing.Type[VpnCustomErrorBox]) -> VpnCustomErrorBox:...

class VpnCustomPromptBooleanInput(_winrt.Object):
    initial_value: _winrt.Boolean
    value: _winrt.Boolean
    emphasized: _winrt.Boolean
    display_name: str
    compulsory: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomPromptBooleanInput: ...
    def __new__(cls: typing.Type[VpnCustomPromptBooleanInput]) -> VpnCustomPromptBooleanInput:...

class VpnCustomPromptOptionSelector(_winrt.Object):
    emphasized: _winrt.Boolean
    display_name: str
    compulsory: _winrt.Boolean
    options: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    selected_index: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomPromptOptionSelector: ...
    def __new__(cls: typing.Type[VpnCustomPromptOptionSelector]) -> VpnCustomPromptOptionSelector:...

class VpnCustomPromptText(_winrt.Object):
    emphasized: _winrt.Boolean
    display_name: str
    compulsory: _winrt.Boolean
    text: str
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomPromptText: ...
    def __new__(cls: typing.Type[VpnCustomPromptText]) -> VpnCustomPromptText:...

class VpnCustomPromptTextInput(_winrt.Object):
    emphasized: _winrt.Boolean
    display_name: str
    compulsory: _winrt.Boolean
    placeholder_text: str
    is_text_hidden: _winrt.Boolean
    text: str
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomPromptTextInput: ...
    def __new__(cls: typing.Type[VpnCustomPromptTextInput]) -> VpnCustomPromptTextInput:...

class VpnCustomTextBox(_winrt.Object):
    label: str
    compulsory: _winrt.Boolean
    bordered: _winrt.Boolean
    display_text: str
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnCustomTextBox: ...
    def __new__(cls: typing.Type[VpnCustomTextBox]) -> VpnCustomTextBox:...

class VpnDomainNameAssignment(_winrt.Object):
    proxy_auto_configuration_uri: typing.Optional[winsdk.windows.foundation.Uri]
    domain_name_list: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnDomainNameAssignment: ...
    def __new__(cls: typing.Type[VpnDomainNameAssignment]) -> VpnDomainNameAssignment:...

class VpnDomainNameInfo(_winrt.Object):
    domain_name_type: VpnDomainNameType
    domain_name: typing.Optional[winsdk.windows.networking.HostName]
    dns_servers: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName]]
    web_proxy_servers: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName]]
    web_proxy_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnDomainNameInfo: ...
    def __new__(cls: typing.Type[VpnDomainNameInfo], name: str, name_type: VpnDomainNameType, dns_server_list: typing.Iterable[winsdk.windows.networking.HostName], proxy_server_list: typing.Iterable[winsdk.windows.networking.HostName]) -> VpnDomainNameInfo:...

class VpnForegroundActivatedEventArgs(_winrt.Object):
    kind: winsdk.windows.applicationmodel.activation.ActivationKind
    previous_execution_state: winsdk.windows.applicationmodel.activation.ApplicationExecutionState
    splash_screen: typing.Optional[winsdk.windows.applicationmodel.activation.SplashScreen]
    user: typing.Optional[winsdk.windows.system.User]
    activation_operation: typing.Optional[VpnForegroundActivationOperation]
    profile_name: str
    shared_context: typing.Optional[winsdk.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnForegroundActivatedEventArgs: ...

class VpnForegroundActivationOperation(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnForegroundActivationOperation: ...
    def complete(self, result: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> None: ...

class VpnInterfaceId(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnInterfaceId: ...
    def __new__(cls: typing.Type[VpnInterfaceId], address: typing.Sequence[_winrt.UInt8]) -> VpnInterfaceId:...
    def get_address_info(self) -> typing.List[_winrt.UInt8]: ...

class VpnManagementAgent(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnManagementAgent: ...
    def __new__(cls: typing.Type[VpnManagementAgent]) -> VpnManagementAgent:...
    def add_profile_from_object_async(self, profile: typing.Optional[IVpnProfile]) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def add_profile_from_xml_async(self, xml: str) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def connect_profile_async(self, profile: typing.Optional[IVpnProfile]) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def connect_profile_with_password_credential_async(self, profile: typing.Optional[IVpnProfile], password_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def delete_profile_async(self, profile: typing.Optional[IVpnProfile]) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def disconnect_profile_async(self, profile: typing.Optional[IVpnProfile]) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def get_profiles_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[IVpnProfile]]: ...
    def update_profile_from_object_async(self, profile: typing.Optional[IVpnProfile]) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...
    def update_profile_from_xml_async(self, xml: str) -> winsdk.windows.foundation.IAsyncOperation[VpnManagementErrorStatus]: ...

class VpnNamespaceAssignment(_winrt.Object):
    proxy_auto_config_uri: typing.Optional[winsdk.windows.foundation.Uri]
    namespace_list: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnNamespaceInfo]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnNamespaceAssignment: ...
    def __new__(cls: typing.Type[VpnNamespaceAssignment]) -> VpnNamespaceAssignment:...

class VpnNamespaceInfo(_winrt.Object):
    web_proxy_servers: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName]]
    namespace: str
    dns_servers: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnNamespaceInfo: ...
    def __new__(cls: typing.Type[VpnNamespaceInfo], name: str, dns_server_list: winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName], proxy_server_list: winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName]) -> VpnNamespaceInfo:...

class VpnNativeProfile(_winrt.Object):
    user_authentication_method: VpnAuthenticationMethod
    tunnel_authentication_method: VpnAuthenticationMethod
    routing_policy_type: VpnRoutingPolicyType
    eap_configuration: str
    native_protocol_type: VpnNativeProtocolType
    servers: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    require_vpn_client_app_u_i: _winrt.Boolean
    connection_status: VpnManagementConnectionStatus
    profile_name: str
    remember_credentials: _winrt.Boolean
    always_on: _winrt.Boolean
    routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    app_triggers: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnAppId]]
    traffic_filters: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnTrafficFilter]]
    domain_name_info_list: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnNativeProfile: ...
    def __new__(cls: typing.Type[VpnNativeProfile]) -> VpnNativeProfile:...

class VpnPacketBuffer(_winrt.Object):
    transport_affinity: _winrt.UInt32
    status: VpnPacketBufferStatus
    buffer: typing.Optional[winsdk.windows.storage.streams.Buffer]
    app_id: typing.Optional[VpnAppId]
    transport_context: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnPacketBuffer: ...
    def __new__(cls: typing.Type[VpnPacketBuffer], parent_buffer: typing.Optional[VpnPacketBuffer], offset: _winrt.UInt32, length: _winrt.UInt32) -> VpnPacketBuffer:...

class VpnPacketBufferList(_winrt.Object):
    status: VpnPacketBufferStatus
    size: _winrt.UInt32
    def __iter__(self) -> winsdk.windows.foundation.collections.IIterator[VpnPacketBuffer]: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnPacketBufferList: ...
    def add_at_begin(self, next_vpn_packet_buffer: typing.Optional[VpnPacketBuffer]) -> None: ...
    def append(self, next_vpn_packet_buffer: typing.Optional[VpnPacketBuffer]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[VpnPacketBuffer]]: ...
    def remove_at_begin(self) -> typing.Optional[VpnPacketBuffer]: ...
    def remove_at_end(self) -> typing.Optional[VpnPacketBuffer]: ...

class VpnPickedCredential(_winrt.Object):
    additional_pin: str
    old_password_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    passkey_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnPickedCredential: ...

class VpnPlugInProfile(_winrt.Object):
    vpn_plugin_package_family_name: str
    custom_configuration: str
    server_uris: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.foundation.Uri]]
    require_vpn_client_app_u_i: _winrt.Boolean
    connection_status: VpnManagementConnectionStatus
    profile_name: str
    remember_credentials: _winrt.Boolean
    always_on: _winrt.Boolean
    app_triggers: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnAppId]]
    domain_name_info_list: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    traffic_filters: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnTrafficFilter]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnPlugInProfile: ...
    def __new__(cls: typing.Type[VpnPlugInProfile]) -> VpnPlugInProfile:...

class VpnRoute(_winrt.Object):
    prefix_size: _winrt.UInt8
    address: typing.Optional[winsdk.windows.networking.HostName]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnRoute: ...
    def __new__(cls: typing.Type[VpnRoute], address: typing.Optional[winsdk.windows.networking.HostName], prefix_size: _winrt.UInt8) -> VpnRoute:...

class VpnRouteAssignment(_winrt.Object):
    ipv6_inclusion_routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    ipv6_exclusion_routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    ipv4_inclusion_routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    ipv4_exclusion_routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    exclude_local_subnets: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnRouteAssignment: ...
    def __new__(cls: typing.Type[VpnRouteAssignment]) -> VpnRouteAssignment:...

class VpnSystemHealth(_winrt.Object):
    statement_of_health: typing.Optional[winsdk.windows.storage.streams.Buffer]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnSystemHealth: ...

class VpnTrafficFilter(_winrt.Object):
    routing_policy_type: VpnRoutingPolicyType
    protocol: VpnIPProtocol
    app_id: typing.Optional[VpnAppId]
    app_claims: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    local_address_ranges: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    local_port_ranges: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    remote_address_ranges: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    remote_port_ranges: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnTrafficFilter: ...
    def __new__(cls: typing.Type[VpnTrafficFilter], app_id: typing.Optional[VpnAppId]) -> VpnTrafficFilter:...

class VpnTrafficFilterAssignment(_winrt.Object):
    allow_outbound: _winrt.Boolean
    allow_inbound: _winrt.Boolean
    traffic_filter_list: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnTrafficFilter]]
    @staticmethod
    def _from(obj: _winrt.Object) -> VpnTrafficFilterAssignment: ...
    def __new__(cls: typing.Type[VpnTrafficFilterAssignment]) -> VpnTrafficFilterAssignment:...

class IVpnChannelStatics(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnChannelStatics: ...
    def process_event_async(self, third_party_plug_in: typing.Optional[_winrt.Object], event: typing.Optional[_winrt.Object]) -> None: ...

class IVpnCredential(_winrt.Object):
    additional_pin: str
    certificate_credential: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    old_password_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    passkey_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnCredential: ...

class IVpnCustomPrompt(_winrt.Object):
    bordered: _winrt.Boolean
    compulsory: _winrt.Boolean
    label: str
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnCustomPrompt: ...

class IVpnCustomPromptElement(_winrt.Object):
    compulsory: _winrt.Boolean
    display_name: str
    emphasized: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnCustomPromptElement: ...

class IVpnDomainNameInfoFactory(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnDomainNameInfoFactory: ...
    def create_vpn_domain_name_info(self, name: str, name_type: VpnDomainNameType, dns_server_list: typing.Iterable[winsdk.windows.networking.HostName], proxy_server_list: typing.Iterable[winsdk.windows.networking.HostName]) -> typing.Optional[VpnDomainNameInfo]: ...

class IVpnInterfaceIdFactory(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnInterfaceIdFactory: ...
    def create_vpn_interface_id(self, address: typing.Sequence[_winrt.UInt8]) -> typing.Optional[VpnInterfaceId]: ...

class IVpnNamespaceInfoFactory(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnNamespaceInfoFactory: ...
    def create_vpn_namespace_info(self, name: str, dns_server_list: winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName], proxy_server_list: winsdk.windows.foundation.collections.IVector[winsdk.windows.networking.HostName]) -> typing.Optional[VpnNamespaceInfo]: ...

class IVpnPacketBufferFactory(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnPacketBufferFactory: ...
    def create_vpn_packet_buffer(self, parent_buffer: typing.Optional[VpnPacketBuffer], offset: _winrt.UInt32, length: _winrt.UInt32) -> typing.Optional[VpnPacketBuffer]: ...

class IVpnPlugIn(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnPlugIn: ...
    def connect(self, channel: typing.Optional[VpnChannel]) -> None: ...
    def decapsulate(self, channel: typing.Optional[VpnChannel], encap_buffer: typing.Optional[VpnPacketBuffer], decapsulated_packets: typing.Optional[VpnPacketBufferList], control_packets_to_send: typing.Optional[VpnPacketBufferList]) -> None: ...
    def disconnect(self, channel: typing.Optional[VpnChannel]) -> None: ...
    def encapsulate(self, channel: typing.Optional[VpnChannel], packets: typing.Optional[VpnPacketBufferList], encapulated_packets: typing.Optional[VpnPacketBufferList]) -> None: ...
    def get_keep_alive_payload(self, channel: typing.Optional[VpnChannel]) -> typing.Optional[VpnPacketBuffer]: ...

class IVpnProfile(_winrt.Object):
    always_on: _winrt.Boolean
    app_triggers: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnAppId]]
    domain_name_info_list: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnDomainNameInfo]]
    profile_name: str
    remember_credentials: _winrt.Boolean
    routes: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnRoute]]
    traffic_filters: typing.Optional[winsdk.windows.foundation.collections.IVector[VpnTrafficFilter]]
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnProfile: ...

class IVpnRouteFactory(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IVpnRouteFactory: ...
    def create_vpn_route(self, address: typing.Optional[winsdk.windows.networking.HostName], prefix_size: _winrt.UInt8) -> typing.Optional[VpnRoute]: ...

