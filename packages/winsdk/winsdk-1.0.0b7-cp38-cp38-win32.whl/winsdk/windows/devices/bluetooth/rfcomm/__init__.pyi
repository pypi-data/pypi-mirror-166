# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.7

import datetime
import sys
import types
import typing

import winsdk._winrt as _winrt
import winsdk.windows.devices.bluetooth
import winsdk.windows.devices.enumeration
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.networking
import winsdk.windows.networking.sockets
import winsdk.windows.storage.streams

Self = typing.TypeVar('Self')

class RfcommDeviceService(_winrt.Object):
    connection_host_name: typing.Optional[winsdk.windows.networking.HostName]
    connection_service_name: str
    max_protection_level: winsdk.windows.networking.sockets.SocketProtectionLevel
    protection_level: winsdk.windows.networking.sockets.SocketProtectionLevel
    service_id: typing.Optional[RfcommServiceId]
    device: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothDevice]
    device_access_information: typing.Optional[winsdk.windows.devices.enumeration.DeviceAccessInformation]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> RfcommDeviceService: ...
    def close(self) -> None: ...
    @staticmethod
    def from_id_async(device_id: str) -> winsdk.windows.foundation.IAsyncOperation[RfcommDeviceService]: ...
    @staticmethod
    def get_device_selector(service_id: typing.Optional[RfcommServiceId]) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector_for_bluetooth_device(bluetooth_device: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothDevice]) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector_for_bluetooth_device(bluetooth_device: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothDevice], cache_mode: winsdk.windows.devices.bluetooth.BluetoothCacheMode) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector_for_bluetooth_device_and_service_id(bluetooth_device: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothDevice], service_id: typing.Optional[RfcommServiceId]) -> str: ...
    @typing.overload
    @staticmethod
    def get_device_selector_for_bluetooth_device_and_service_id(bluetooth_device: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothDevice], service_id: typing.Optional[RfcommServiceId], cache_mode: winsdk.windows.devices.bluetooth.BluetoothCacheMode) -> str: ...
    @typing.overload
    def get_sdp_raw_attributes_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IMapView[_winrt.UInt32, winsdk.windows.storage.streams.IBuffer]]: ...
    @typing.overload
    def get_sdp_raw_attributes_async(self, cache_mode: winsdk.windows.devices.bluetooth.BluetoothCacheMode) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IMapView[_winrt.UInt32, winsdk.windows.storage.streams.IBuffer]]: ...
    def request_access_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.devices.enumeration.DeviceAccessStatus]: ...

class RfcommDeviceServicesResult(_winrt.Object):
    error: winsdk.windows.devices.bluetooth.BluetoothError
    services: typing.Optional[winsdk.windows.foundation.collections.IVectorView[RfcommDeviceService]]
    @staticmethod
    def _from(obj: _winrt.Object) -> RfcommDeviceServicesResult: ...

class RfcommServiceId(_winrt.Object):
    uuid: _winrt.Guid
    generic_file_transfer: typing.Optional[RfcommServiceId]
    obex_file_transfer: typing.Optional[RfcommServiceId]
    obex_object_push: typing.Optional[RfcommServiceId]
    phone_book_access_pce: typing.Optional[RfcommServiceId]
    phone_book_access_pse: typing.Optional[RfcommServiceId]
    serial_port: typing.Optional[RfcommServiceId]
    @staticmethod
    def _from(obj: _winrt.Object) -> RfcommServiceId: ...
    def as_short_id(self) -> _winrt.UInt32: ...
    def as_string(self) -> str: ...
    @staticmethod
    def from_short_id(short_id: _winrt.UInt32) -> typing.Optional[RfcommServiceId]: ...
    @staticmethod
    def from_uuid(uuid: _winrt.Guid) -> typing.Optional[RfcommServiceId]: ...

class RfcommServiceProvider(_winrt.Object):
    sdp_raw_attributes: typing.Optional[winsdk.windows.foundation.collections.IMap[_winrt.UInt32, winsdk.windows.storage.streams.IBuffer]]
    service_id: typing.Optional[RfcommServiceId]
    @staticmethod
    def _from(obj: _winrt.Object) -> RfcommServiceProvider: ...
    @staticmethod
    def create_async(service_id: typing.Optional[RfcommServiceId]) -> winsdk.windows.foundation.IAsyncOperation[RfcommServiceProvider]: ...
    @typing.overload
    def start_advertising(self, listener: typing.Optional[winsdk.windows.networking.sockets.StreamSocketListener]) -> None: ...
    @typing.overload
    def start_advertising(self, listener: typing.Optional[winsdk.windows.networking.sockets.StreamSocketListener], radio_discoverable: _winrt.Boolean) -> None: ...
    def stop_advertising(self) -> None: ...

