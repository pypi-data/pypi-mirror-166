# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_collection.ipynb.

# %% auto 0
__all__ = ['NFTCollection']

# %% ../01_collection.ipynb 3
import pandas as pd
from dateparser import parse as parse_date
from functools import cache
from dataclasses import dataclass
from datetime import datetime, timedelta
from .connectors import RSConnector
from fastcore.utils import patch

# %% ../01_collection.ipynb 4
def _parse_start_end_dates(start_time: str, end_time: str = "now") -> tuple[datetime]:
    # ensure you have end_time:
    end_time = end_time or 'now'
    shortcuts = {
        # put more here, but should be convertible to dateparser lib conventions.
        "latest": 'now',
    }
    start_time = str(datetime.utcnow().date()) if start_time == 'today' else start_time
    if start_time in shortcuts: start_time = shortcuts[start_time]
    return parse_date(start_time, settings={'TIMEZONE': 'UTC'}), parse_date(end_time, settings={'TIMEZONE': 'UTC'})

# %% ../01_collection.ipynb 6
def _build_trade_statement(chain: str, start_dt:datetime, end_dt:datetime, collection_address:str=''):    
    _select = f"select * from onchain.{('trades' if chain =='eth' else f'{chain}_trades')} where"
    _collection_filter = f"collection_address='{collection_address}'"
    _time_filter = f"timestamp >= {round(start_dt.timestamp())} and timestamp <= {round(end_dt.timestamp())}"
    #combine here...
    _filters = ' and '.join([_collection_filter, _time_filter]) if collection_address else _time_filter
    return ' '.join([_select, _filters])

# %% ../01_collection.ipynb 8
@cache
def _fetch_trades(conn: RSConnector,
                 start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
                 end_time: str = 'now', # default now. Same type as start_time 
                 chain:str = 'eth', 
                 collection_address: str = ''
                ) -> pd.DataFrame:
    start_dt, end_dt = _parse_start_end_dates(start_time, end_time=end_time)
    return conn.query(_build_trade_statement(chain, start_dt, end_dt, collection_address=collection_address))

# %% ../01_collection.ipynb 9
class NFTCollection:
    """NFT Collection object"""
    def __init__(self,
                 conn: RSConnector,
                 collection_id: str, # collection_address checksummed e.g. 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
                 chain: str ='eth'): # chain_id - currently only "eth" or "bnb" allowed
        self._conn, self.chain, self.collection_id = conn, chain, collection_id
    @cache
    def socials(self):
        return dict()

# %% ../01_collection.ipynb 10
@patch
def trades(self: NFTCollection,
           start_time: str, # start time in UTC. You can use shortcuts like today, yesterday or even clauses such as "1 day/week ago".
           end_time: str = 'now' # default now. Same type as start_time 
          ):
    return _fetch_trades(
        self._conn,
        start_time, 
        end_time=end_time, 
        chain=self.chain,
        collection_address=self.collection_id
    ) 

