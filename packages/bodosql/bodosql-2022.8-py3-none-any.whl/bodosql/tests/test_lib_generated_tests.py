# Copyright (C) 2022 Bodo Inc. All rights reserved.
"""
Tests the correctness of the automatically generated library tests.
These test cases will most likely be removed later
"""
import operator

import bodosql
import numpy as np
import pytest
from numba import generated_jit

import bodo
import buildscripts.python_library_build.generate_library_tests


def generate_fn_test_implementations(
    lib_fn_string, lib_fn_name, arg_values, expected_outputs, use_np_close
):
    """
    takes a string python function, a plaintext name for the function (specifically,
    a name that can used in a python function declaration, IE def test_{fnName}()),
    a nested list of function inputs in the form of arg_values[inputNo][argNo],
    and a list of the expected outputs for each set of function inputs,
    in the form of expected_outputs[inputNo]

    For example, assume we have
    arg_values = [[1,2,3], [3,2,1]]
    expected_outputs = [1, 3]
    we will generate tests assuming that fn(1,2,3) == 1 and fn(3,2,1) == 3
    It is required that each nested list within arg_values has the same length

    Generates the implementations for the functions that test the default behavior,
    the None behavior, and the optional behavior of the JIT function.
    """

    (
        default_tests,
        none_tests,
        opt_tests,
    ) = buildscripts.python_library_build.generate_library_tests.generate_fn_test_strings(
        lib_fn_string, lib_fn_name, arg_values, expected_outputs, use_np_close
    )

    num_function_inputs = len(arg_values)
    num_args = len(arg_values[0])
    locs = {}
    combined_func_text = "\n".join(default_tests + none_tests + opt_tests)
    exec(
        combined_func_text,
        {
            "bodo": bodo,
            "generated_jit": generated_jit,
            "pytest": pytest,
            "bodosql": bodosql,
            "operator": operator,
            "np": np,
        },
        locs,
    )

    default_tests_impls = []
    none_tests_impls = []
    opt_tests_impls = []

    for i in range(num_function_inputs):
        default_tests_impls.append(locs[f"test_{lib_fn_name}_default_input_{i}"])

    for i in range(num_args):
        none_tests_impls.append(locs[f"test_{lib_fn_name}_None_Arg_{i}"])

    for i in range(num_args + 1):
        opt_tests_impls.append(locs[f"test_{lib_fn_name}_optional_num_{i}"])

    return (default_tests_impls, none_tests_impls, opt_tests_impls)


# The correctness of bodosql.libs.null_handling functions have been checked in another file. Therefore, we expect these
# the autogenerated tests to succeed here.
@pytest.mark.slow
def test_correct_impl():
    (
        default_not_tests,
        none_not_tests,
        optional_not_tests,
    ) = generate_fn_test_implementations(
        "bodosql.libs.null_handling.scalar_nullable_logical_not",
        "not",
        [["True"], ["False"]],
        ["False", "True"],
        False,
    )
    (
        default_add_tests,
        none_add_tests,
        optional_add_tests,
    ) = generate_fn_test_implementations(
        "bodosql.libs.null_handling.scalar_nullable_add",
        "addition",
        [["2", ".12321"], [".3233", "4"]],
        ["2.12321", "4.3233"],
        True,
    )

    for fn in (
        default_not_tests
        + none_not_tests
        + optional_not_tests
        + default_add_tests
        + none_add_tests
        + optional_add_tests
    ):
        fn()


@pytest.mark.slow
def test_faulty_impl():
    """Tests that the generated library functions correctly throw errors when testing implementations
    which do not properly handle null values"""

    # Generating test cases that check the behavior of the default python
    # addition and logical negation operators
    (
        default_not_tests,
        none_not_tests,
        optional_not_tests,
    ) = generate_fn_test_implementations(
        "not", "not", [["True"], ["False"]], ["False", "True"], False
    )
    (
        default_add_tests,
        none_add_tests,
        optional_add_tests,
    ) = generate_fn_test_implementations(
        "operator.add",
        "addition",
        [["2", ".12321"], [".3233", "4"]],
        ["2.12321", "4.3233"],
        True,
    )

    # we expect tests that do not involve None/optional types to work as expected
    for fn in default_add_tests + default_not_tests:
        fn()

    # we expect tests that do involve None/optional types to fail
    # we'll check one tets for none and optional from each automatically generated implementation
    for fn in [
        none_not_tests[0],
        optional_not_tests[0],
        none_add_tests[0],
        optional_add_tests[0],
    ]:
        flag = False
        try:
            fn()
        except:
            flag = True
        assert flag
