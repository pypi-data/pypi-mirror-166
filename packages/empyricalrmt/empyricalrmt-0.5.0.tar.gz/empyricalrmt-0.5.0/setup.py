# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['empyricalRMT', 'empyricalRMT.observables', 'empyricalRMT.signalproc']

package_data = \
{'': ['*']}

install_requires = \
['EMD-signal>=1.2.3,<2.0.0',
 'matplotlib>=3.5.3,<4.0.0',
 'numba>=0.56.2,<0.57.0',
 'numpy>=1.23.3,<2.0.0',
 'pandas>=1.4.4,<2.0.0',
 'pyod>=1.0.4,<2.0.0',
 'scikit-learn>=1.1.2,<2.0.0',
 'scipy>=1.9.1,<2.0.0',
 'seaborn>=0.12.0,<0.13.0',
 'statsmodels>=0.13.2,<0.14.0',
 'tqdm>=4.64.1,<5.0.0',
 'typing-extensions>=4.3.0,<5.0.0']

setup_kwargs = {
    'name': 'empyricalrmt',
    'version': '0.5.0',
    'description': 'Eigenvalue unfolding and spectral observable computation',
    'long_description': '[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3820650.svg)](https://doi.org/10.5281/zenodo.3820650)\n\n\n# Introduction\n\nA python library for investigating some of the basic / classical elements of\nRandom Matrix Theory, including eigenvalue generation, trimming, unfolding and\ncomputation and plotting of some spectral observables.\n\n# Table of Contents\n- [Introduction](#introduction)\n- [Table of Contents](#table-of-contents)\n  - [Notes on Development](#notes-on-development)\n- [Installation](#installation)\n  - [Local Installation Using `venv` (recommended)](#local-installation-using-venv-recommended)\n  - [Global Installation](#global-installation)\n  - [Windows](#windows)\n- [A Brief Tour](#a-brief-tour)\n- [Documentation](#documentation)\n  - [API Overview](#api-overview)\n    - [Main Classes and Methods](#main-classes-and-methods)\n- [Development](#development)\n  - [Installation](#installation-1)\n  - [Testing](#testing)\n- [Limitations](#limitations)\n\n\n\n## Notes on Development\n\nThis libary is still undergoing significant development. The overall API (e.g.\nbasic classes, properties, and methods) will likely remain stable from this\npoint, but function and method arguments are still quite likely to change. I\ncan\'t provide any guarantees at this point that numerical results will be stable\nfrom version to version.\n\nIn the meantime, please feel free to post issues or ask *any* questions relating\nto the library on [Github](https://github.com/stfxecutables/empyricalRMT/issues).\n\n# Installation\n\nAs always, using a virtual environment is recommended to minimize the chance of\nconflicts. However, you _should_ be okay doing a global `pip install empyricalRMT`\nto try out the library.\n\n\n## Local Installation Using `venv` (recommended)\n\nNavigate to the project that you wish to use empyricalRMT in.\n\n```bash\ncd MyProject\n```\n\nCreate and active the virtual environment. Replace "env" with whatever name\nyou prefer.\n\n```bash\npython -m venv env && source env/bin/activate\n```\n\nNow install locally either from pip:\n\n```bash\npip install --upgrade empyricalRMT\n```\n\nor from source:\n\n```bash\ngit clone https://github.com/stfxecutables/empyricalRMT /path/to/your/favourite/location/empyricalRMT\ncd MyProject  #\npip install -e /path/to/your/favourite/location/empyricalRMT\n```\n\nIf using Windows (which I haven\'t tested this library on), you *should* be able to\ninstall this in whatever manner you usually install libraries from source or pip.\n\n\n## Global Installation\n\nVia pip:\n\n```bash\npip install empyricalRMT\n```\n\nFrom source:\n\n```bash\ngit clone https://github.com/stfxecutables/empyricalRMT\ncd empyricalRMT\npip install -e .\n```\n\nNote that this will install the library "globally" if you haven\'t activated\na virtual environment of some kind.\n\n\n\n## Windows\n\nThe above *should* still all work on Windows, although you may have to follow\n[modified instructions for setting up the *venv*](https://docs.python.org/3/library/venv.html).\n\nIf you run into issues specific to this library that you think might be\nWindows-related, please do report them, but keep in mind I currently can only\ntest on Windows via virtual machine :(\n\n# A Brief Tour\n\nNumerically investigate the extent to which a GOE matrix agrees with theory:\n\n```python\nimport empyricalRMT as rmt\n\nfrom empyricalRMT.construct import generate_eigs\nfrom empyricalRMT.eigenvalues import Eigenvalues\n\n# generate eigenvalues from a 1000x1000 matrix from the Gaussian Orthogonal Ensemble\nvals = generate_eigs(matsize=1000, kind="goe")\neigs = Eigenvalues(eigs)\n\n# verify Wigner\'s semicircle law:\neigs.plot_distribution()\n```\n![Wigner\'s Semicircle](readme/semicircle.png)\n\n```python\n# unfold the eigenvalues via Wigner\'s semi-circle law:\nunfolded = eigs.unfold(smoother="goe")\n# or unfold via polynomial:\nunfolded = eigs.unfold(smoother="poly", degree=7)\n# optionally detrend unfolded vals via Empirical Mode Decomposition:\nunfolded = eigs.unfold(smoother="poly", degree=7, detrend=True)\n\n# plot some classic observables and compare to theory\nensembles = ["poisson", "goe"]  # theoretically expected curves to plot\nunfolded.plot_nnsd(ensembles=ensembles)  # nearest neighbours spacings\nunfolded.plot_nnnsd(ensembles=["goe"])  # next-nearest neighbours spacings\nunfolded.plot_spectral_rigidity(ensembles=ensembles)\nunfolded.plot_level_variance(ensembles=ensembles)\n```\n![nnsd](readme/nnsd.png)\n![nnnsd](readme/nnnsd.png)\n![rigidity](readme/rigidity.png)\n![variance](readme/variance.png)\n\nVisually inspect / detect a bad unfolding fit:\n\n```python\nfrom empyricalRMT.eigenvalues import Eigenvalues\n\n# generate time series data\nT = np.random.standard_normal([1000, 250])\neigs = Eigenvalues.from_time_series(T, trim_zeros=False)\nunfolded = eigs.unfold(degree=5)\nunfolded.plot_fit()\n```\n\n![bad fit](readme/unfoldfit.png)\n\n\nSample eigenvalues from *large* GOE matrices (provided they can fit in memory) ***fast*** via\n[equivalently distributed tridiagonal matrices](https://dspace.mit.edu/handle/1721.1/115982):\n\n```python\nfrom empyricalRMT.construct import generate_eigs\n\neigs = generate_eigs(matsize=30000, kind="goe", log=True)\n\n""" Output:\n>>> 15:40:39 (Mar10) -- computing eigenvalues...\n>>> 15:41:05 (Mar10) -- computed eigenvalues.\n"""\n```\nE.g. under 30 seconds (Processor: 4-core / 8-threads, Intel(R)\nXeon(R) CPU E3-1575M v5 @ 3.00GHz).\n\n\n\n\n# Documentation\n\nThe [source code](https://github.com/stfxecutables/empyricalRMT/tree/master/empyricalRMT)\nis well documented, so be sure to read the documentation comments. If you are\nusing Python interactively (e.g. in a Jupyter notebook or REPL) then these\ncomments are quickly available by calling `help(rmt_object)`. If you are using\na decent IDE or editor with appropriate extensions (e.g. PyCharm, VS Code) you\nshould be able to see the documentation on mouse hover or via your editor shortcuts.\n\nThis README also includes an API overview below, which can be used if you want a\nquick overview of the available features, or if you want to access the\ndocumentation interactively.\n\n## API Overview\n\nThe below should allow easier access to documentation via Python\'s native `help`\ne.g. via calls like `help(Eigenvalues.trim_report)`. The various functions,\nmethods, and properties below do not represent an exhaustive (or even\nnecessarily up-to-date) list of what is available in the library, and are\nintended simply as an overview for convenience. Full and updated documentation\ncan be found in the source code.\n\n### Main Classes and Methods\n\nClass for working with or extracting raw (e.g. untrimmed, not-yet unfolded)\neigenvalues:\n\n```python\nfrom empyricalRMT.eigenvalues import Eigenvalues\n\nclass Eigenvalues  # subclass of EigVals\n  # Constructors\n  .__init__()\n  .from_correlations()\n  .from_time_series()\n\n  # Properties\n  .values\n  .vals\n  .eigenvalues\n  .eigs\n\n  # Methods\n  .trim_report()\n  .get_best_trimmed()\n  .trim_marchenko_pastur()\n  .trim_manually()\n  .trim_unfold_auto()\n  .trim_interactively()  # Not implemented!\n  .unfold()\n```\n\nUtilities for operating on unfolded eigenvalues:\n\n```python\nfrom empyricalRMT.unfold import Unfolded\n\nclass Unfolded  # subclass of EigVals\n  # Properties\n  .values\n  .vals\n\n  # Methods\n  .spectral_rigidity()\n  .level_variance()\n  .plot_fit()\n  .plot_nnsd()\n  .plot_next_nnsd()\n  .plot_nnsd()\n  .plot_spectral_rigidity()\n  .plot_level_variance()\n  .plot_observables()\n  .evaluate_smoother()\n  .ensemble_compare()  # Under active development. Beware!\n```\n\nMinimal class only returned from trimming functions:\n\n```python\nfrom empyricalRMT.trim import Trimmed\n\nclass Trimmed  # subclass of EigVals\n  # Constructors\n  .__init__()\n\n  # Properties\n  .values\n  .vals\n\n  # Methods\n  .unfold()\n  .unfold_auto()\n```\n\nShared methods for above classes (not intended to be used directly):\n\n```python\nclass EigVals  # methods and properties common to Eigenvalues, Trimmed, Unfolded classes\n  # Properties\n  .original_values\n  .original_eigs\n  .original_eigenvalues\n  .values\n  .vals\n  .steps\n  .spacings\n\n  # Methods\n  .step_function()\n  .plot_sorted()\n  .plot_distribution()\n  .plot_steps()\n  .plot_spacings()\n```\n\nUtilities for summarizing trims and unfoldings:\n\n```python\nfrom empyricalRMT.trim import TrimReport\n\nclass TrimReport\n  # Properties\n  .trim_indices\n  .untrimmed\n  .summary\n  .unfoldings\n\n  # Methods\n  .use_trim_iteration()\n  .evaluate()\n  .best_overall()\n  .unfold_trimmed()\n  .plot_trim_steps()\n  .to_csv()\n```\n\nExpected ensemble curves and/or distribution values:\n\n```python\nfrom empyricalRMT.ensemble import GOE, GUE, GSE, GDE, Poisson\n\nclass Ensemble  # base class for classes: GOE, GUE, GSE, Poisson / GDE\n  # Static Methods\n  .nnsd()\n  .nnnsd()\n  .spectral_rigidity()\n  .level_variance()\n```\n\nFunctions for generating eigenvalues according to various ensembles:\n\n```python\nimport empyricalRMT.construct as rmt\n\nrmt.generate_eigs()\nrmt.goe_unfolded()\nrmt.tracy_widom_eigs()\n```\n\n# Development\n\n## Installation\n\nAssuming you want your `venv` virtual environment to be named "env":\n\n```bash\ngit clone https://github.com/stfxecutables/empyricalRMT\ncd empyricalRMT\npython -m venv env\nsource env/bin/activate\npython -m pip install -r requirements-dev.txt\npip install -e .  # to make editable\n```\n\n## Testing\n\nTo run all tests, run:\n\n```bash\npython -m pytest -v\n```\n\nThere are a number of pytest _marks_ labelling different testing aspects.\nBrief descriptions can be found in `pytest.ini`. However, likely most useful\nwill be running:\n\n```bash\npython -m pytest -v -m fast\n```\n\nwhich runs all tests that _shouldn\'t_ take too long to execute.\n\n# Limitations\n\nThis library was and is being developed on a reasonably decent machine (4 cores\n/ 8 threads, 3.00GHz, 64GB RAM) that is currently running Ubuntu 18.04 LTS. Out\nof convenience, I have used Numba, but I know that this is not the most portable\nsolution available, and may result in some issues.\n\nDefault values for most parameters were chosen because they provided reasonably\naccurate results (e.g. when compared to as predicted by theory) in reasonable\namounts of time on *this machine*. I have tested the library on my old 2015\nMacBook, and the defaults seem *okay*, but it is possible that they may not work\nwell on your machine, especially with regards to memory. I hope to implement\nmethods that can work around memory issues in the future (e.g. using memory\nmaps, dask, and perhaps more sophisticated methods in some cases) but for now,\nthis is a limitation of the library.\n\nAddtionally, RMT results are theoretical, and many results only hold as N\napproaches infinity. In practice, it seems that floating-point precision issues\n(whether in numerical integration, solving of eigenproblems, or in the\nconvergence of some of the stochastic methods used in this library) plus the\nreality of working with finite matrices means that there are significant limits\non the extent to which simulations agree with theory, especially when looking at\nlong-range spectral observables (e.g. spectral rigidity or level number variance\nfor L > 20).\n\nFinally, I am just a dabbler in RMT. I have tried to limit myself to\nimplementing only aspects I feel I understand, but I may have made some basic\nerrors in implementation or understanding at some point. If you notice any\nissues or mistakes, corrections are always warmly welcomed!\n',
    'author': 'Derek M Berger',
    'author_email': 'dmberger.dev@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<3.12',
}


setup(**setup_kwargs)
